[{"title":"Golang 抓包分析MySQL的数据传输过程","date":"2019-03-19T06:20:43.000Z","path":"2019/03/19/Untitled/","text":"抓包分析MySQL的数据传输过程1）一段完整的data/sql代码1234567891011121314151617181920212223242526272829303132333435import ( \"fmt\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\")func main() &#123; dbName := \"root:root@tcp(192.168.133.128:3306)/monitor?charset=utf8\" dbConn, err := sql.Open(\"mysql\", dbName) if err != nil &#123; fmt.Println(err.Error()) return &#125; stmtIn, err := dbConn.Prepare(\"Select count(*) from process\") if err != nil&#123; fmt.Println(\"Prepare Fail\") return &#125; fmt.Println(\"Prepare Success\") var count int err = stmtIn.QueryRow().Scan(&amp;count) if err != nil &amp;&amp; err != sql.ErrNoRows &#123; return &#125; fmt.Println(\"count = \",count) defer stmtIn.Close()&#125; 代码运行结果如下： 1234D:\\workspace\\go\\src\\tryme\\sqlλ go run .Prepare Successcount = 2 2）接口API规范文档3）报文交互整个过程的报文截图： 报文序号：1~3 经典的TCP连接建立过程，需要经过三次握手。 说明MySQL建立的是TCP的连接。 报文序号：4~7 第4号报文，MySQL服务器向客户端发送了一个问候，需要客户端验明正身。 第5号报文，Client端将账号与密码以及请求的数据库名发送到服务端，其中密码是加密传输的过程。 第7号报文表示验证通过。 报文序号：8~11 第8号报文设置读取的编码格式，此处为UTF-8。 第10号报文是执行Prepare Command的过程，向服务端请求连接准备，此时服务端将从连接池中选择1个连接。 第11号报文，服务端将选择好的连接信息（连接池ID）发送到客户端，此时客户端可以使用这个连接池进行数据库的操作。 报文序号：12~13 报文12，客户端根据拿到的数据库连接，执行响应的数据库操作： 报文13，服务端将查询结果返回到客户端。 4）总结 MySQL 在传输时使用的是TCP连接，通过三次握手建立连接。 MySQL在执行SQL过程中，使用的是MySQL自有协议，且为应用层协议。 真正与数据库连接是从Prepare之后开始的，而不是sql.Open。 Prepare真正意图是从MySQL中申请到一个数据库连接。","tags":[]},{"title":"Golang json && mysql Data Transfer","date":"2019-03-19T06:02:33.000Z","path":"2019/03/19/Golang-json-mysql-Data-Transfer/","text":"Golang: json &amp;&amp; mysql Data Transfer1 数据流转图​ 在常见的MVC的框架中，涉及到前端UI，后台服务，数据库存储三大块。从编程语言上看，前端使用JavaScript下发JSON数据，后台使用Golang（本项目是Golang）接收前端下发的数据，并将数据存储到MySQL的数据库中。 ​ 整个数据流转关系如下： ​ 2 Client To Server​ UI 层使用的是JSON，支持数字、字符串、布尔型。JSON本身就是JavaScript Object，因此在JS端，所有的数据都是Number、Boolean、String 这三种类型。 ​ 比较幸运，这几种数据类型在常规的编程语言中，都是包含的，如Golang。那么如何来接收从UI端下发的JSON Object，此时需要在Golang中创建一个对应的结构体。 创建1个Struct，建立成员变量名与json目标key的映射关系 JS端下发如下一段JSON： 1234567891011121314&#123; \"network_id\":\"1\", \"network_src_ip\":\"127.0.0.1\", \"network_dst_ip\":\"127.0.0.1\", \"network_dst_port\":3306, \"network_desc\":\"MySQL\", \"network_status\":1, \"network_time_available\":\"2018-07-20T14:42:26+08:00\", \"network_time_unavailable\":\"1970-01-01T08:00:01+08:00\", \"network_group\":0, \"network_alarm_lasttime\":\"1970-01-01T08:00:01+08:00\", \"network_failed_cnt\":0, \"network_disabled\":true&#125; 在Golang中建立如下的结构体，为每个接口体成员打上Tag：JSON Tag中的标签，则表示在JSON中的key 1234567891011121314type PortMonitor struct &#123; ID string `json:\"network_id\"` SrcIP string `json:\"network_src_ip\"` DstIP string `json:\"network_dst_ip\"` DstPort int `json:\"network_dst_port\"` Desc string `json:\"network_desc\"` Status int `json:\"network_status\"` TimeOK time.Time `json:\"network_time_available\"` TimeFail time.Time `json:\"network_time_unavailable\"` Group int `json:\"network_group\"` TimeAlarm time.Time `json:\"network_alarm_lasttime\"` FailCnt int `json:\"network_failed_cnt\"` Disable bool `json:\"network_disabled\"`&#125; json.Unmarshal 完成转换 数据到达服务端时的格式是：[]byte 1234567891011121314151617func CreateProcMonitor(w http.ResponseWriter, r *http.Request, p httprouter.Params) &#123; logger.I(\"call CreateProcMonitor\") res, _ := ioutil.ReadAll(r.Body) uBody := &amp;process.ProcessMonitor&#123;&#125; if err := json.Unmarshal(res, uBody); err != nil &#123; common.SendErrorResponse(w, common.ErrorRequestBodyParseFailed) return &#125; if err := process.DBAddProcMonitorInfo(uBody); err != nil &#123; common.SendErrorResponse(w, common.ErrorDBError) return &#125; common.SendNormalResponse(w, \"Create ProMonitor Info Success\", http.StatusCreated)&#125; 使用函数json:Unmarshal则可以完成JSON结构体向Struct结构体的转换，转换时按照Tag将JSON中的key与Struct中的成员变量名称相对应。 3 Server To DB 从Web服务端调用数据库API执行写库的操作，关键的函数为： 12345678910111213sqlClause := `INSERT INTO network (network_id, network_src_ip, network_dst_ip, network_dst_port, network_desc, network_time_available, network_disabled) VALUES (?, ?, ?, ?, ?, ?, ?)` logger.I(\"sqlClause Insert:%s\", sqlClause) stmtIns, err = dbConn.Prepare(sqlClause) if err != nil &#123; return err &#125; _, err = stmtIns.Exec(portInfo.ID, portInfo.SrcIP, portInfo.DstIP, portInfo.DstPort, portInfo.Desc, portInfo.TimeOK, portInfo.Disable) if err != nil &#123; return err &#125; 核心函数为：stmtIns.Exec 通过实验，证明Exec的参数传递时，支持传统的整型，布尔型，String、time.Time类型等。 4 DB To Server 在数据库中存储的数据，通过接口读取到Go语言中，常用代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func DBGetPortMonitorList(stmt string) ([]*PortMonitor, error) &#123; logger.T(\"Enter Func: DBGetPortMonitorList\") stmtOut, err := dbConn.Prepare(stmt) var res []*PortMonitor if err != nil &#123; return res, err &#125; rows, err := stmtOut.Query() if err != nil &#123; return res, err &#125; defer stmtOut.Close() for rows.Next() &#123; var network_id, network_src_ip, network_dst_ip, network_desc string var network_dst_port, network_status, network_failed_cnt int var network_time_available, network_time_unavailable, network_alarm_lasttime time.Time var network_disabled bool if err := rows.Scan(&amp;network_id, &amp;network_src_ip, &amp;network_dst_ip, &amp;network_dst_port, &amp;network_desc, &amp;network_status, &amp;network_time_available, &amp;network_time_unavailable, &amp;network_alarm_lasttime, &amp;network_failed_cnt, &amp;network_disabled); err != nil &#123; return res, nil &#125; pm := &amp;PortMonitor&#123; ID: network_id, SrcIP: network_src_ip, DstIP: network_dst_ip, DstPort: network_dst_port, Desc: network_desc, Status: network_status, TimeOK: network_time_available, TimeFail: network_time_unavailable, TimeAlarm: network_alarm_lasttime, FailCnt: network_failed_cnt, Disable: network_disabled, &#125; res = append(res, pm) &#125; return res, nil&#125; 获取数据的关键接口是：rows.Scan 通过实验，证明Scan的参数传递时，支持传统的整型，布尔型，String、time.Time类型等。 4 Server To Client 从Golang中将数据返回到客户端，如下代码所示： 1234567891011121314151617181920func GetProcMonitorList(w http.ResponseWriter, r *http.Request, p httprouter.Params) &#123; logger.I(\"call GetProcMonitorList\") stmt := `SELECT id, process_ip, process_name, process_cnt, process_execmd, process_name_find,process_enable_lanch, process_enable_alarm,process_alarm_time,process_groupid,process_switch FROM process` pm, err := process.DBGetProcMonitorList(stmt) if err != nil &#123; logger.E(\"Error When GetProcMonitorList\") common.SendErrorResponse(w, common.ErrorDBError) return &#125; if resp, err := json.Marshal(pm); err != nil &#123; common.SendErrorResponse(w, common.ErrorInternalFaults) return &#125; else &#123; common.SendNormalResponse(w, string(resp), 200) &#125;&#125; 核心的函数是：json.Marshal 这个函数将Struct结构体转变成JSON encode。 通过实验，证明json.Marshal转换后，传递到前端支持传统的整型，布尔型，String、time.Time类型等。 5 time.Time的使用注意事项 对于MySQL的驱动而言，使用Scan方法默认读取到的是[]byte 如果要使得MySQL驱动支持time.Time，需要设置DSN（Data Source Name）parseTime=true。 格式如下： source=root:root@tcp(192.168.133.128:3306)/monitor?loc=Local&amp;parseTime=true&amp;charset=utf8 The default internal output type of MySQL DATE and DATETIME values is []byte which allows you to scan the value into a []byte, string or sql.RawBytes variable in your program. However, many want to scan MySQL DATE and DATETIME values into time.Time variables, which is the logical equivalent in Go to DATE and DATETIME in MySQL. You can do that by changing the internal output type from []byte to time.Time with the DSN parameter parseTime=true. You can set the default time.Time location with the loc DSN parameter. Caution: As of Go 1.1, this makes time.Time the only variable type you can scan DATE and DATETIME values into. This breaks for example sql.RawBytes support. Alternatively you can use the NullTime type as the scan destination, which works with both time.Time and string / []byte. 6 总结 从接口调用的角度： 在设计golang中的结构体时，按照常规的字段的类型声明就可以。","tags":[]},{"title":"Qiniu Image Upload","date":"2019-03-16T13:50:00.000Z","path":"2019/03/16/hello-world/","text":"this article is for uploading imageWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","tags":[]},{"title":"Hexo搭建个人博客站点のSpecil Tips","date":"2019-03-16T06:14:28.000Z","path":"2019/03/16/test-my-site/","text":"Hexo搭建个人博客站点のSpecil Tips1 序言​ Hexo是非常流行的个人站点博客引擎，易学易学，社区教程也非常丰富。 ​ 搭建的教程基本上也是属于手把手级别的，很容易上手。 ​ 本文主要汇总在搭建过程中，自认为比较重要的事项进行记录，方便后续查看。 ​ 关键点： 本文实际采用的网站使用GitHub托管 hexo-admin-qiniu需要结合七牛图床使用 域名解析与CNAME配置文件相结合 2 流程介绍​ 在搭建过程中，主要是参照如下链接： ​ 其中重点参考了从“获得个人网站域名”到“绑定域名”这段过程，主题采用的是BlueLake。 ​ 从选用蓝湖主题开始，参考的是如下的步骤： 3 Special Tips(1) 站点服务器选择​ 国内已经有比较多的云服务器可以选择，如阿里云，腾讯云，华为云等，但是需要注意：如果使用国内的服务器进行网站的搭建，需要对服务器进行许可认证， ​ 即ICP备案。也可以使用国外的服务器，不需要对服务器进行备案。 ​ 本文采用的是vultr服务器，月租相对比较便宜，目前看运行还是比较稳定的。 (2) 每次Deploy时都需要输入密码​ 按照教程，在GitHub的SSH Key的设置界面，将服务器生成的公钥部署完毕。在真正部署时，还是需要输入密码，操作起来非常不便。 ​ 查阅资料后，将根config文件的repo属性进行了如下的更改： 1234deploy: type: git repo: git@github.com:XinhongWu/xinhongwu.github.io.git branch: master ​ 配置完成后，则可以不需要输入密码，即可完成GitHub的推送。 (3) 域名解析CNAME​ 由于网站托管到GitHub上，因此可以使用 github.io格式的网址对网站进行访问。 ​ 对于新申请的域名，需要做一个域名解析的配置，详细配置如下： ​ ​ 需要配置一个CNAME类型和A类型的解析方式。 ​ 光解析到GitHub地址还不够，必须要让GitHub能鉴权通过新注册的域名，因此，需要在博客的source目录下配置一个CNAME文件： ​ ​ 最终会被解析到GitHub的如下位置： ​ (4) 中文标题乱码​ 原因是根config的文件编码格式不是UTF-8，导致推送后显示乱码。 ​ 解决办法：使用Notepad将其编码修改为UTF-8即可。 (5) 设置第三方评论​ 在原生的代码中，有不少的博客评论系统可以选择，如下所示： 12345678910#Cmmentscomment: duoshuo: #chaooo ## duoshuo_shortname disqus: ## disqus_shortname livere: MTAyMC80MzIxNC8xOTc2MA== ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey) ​ 实际发现网易云跟帖已经停止服务了，畅言在申请时需要有网站的备案号，因此本文实际使用的是来必力。 ​ （国外的服务器，不需要在国内备案，畅言可以尝试将没有申请过的备案号输入后申请）。 ​ 注意：来必力的ID可以在data-id中找到，如下所示： ​ (6) 设置代码高亮​ 实际写MD发现，代码并未按照自己的需求高亮，查找资料后发现，还需要额外再添加一个设置： ​ 参考：http://www.mdslq.cn/archives/7266c682.html ​ 在主题config文件中，添加如下的一行： 1highlight_theme: normal (7) 七牛云图片直传​ 七牛云为新用户提供10GB的云存储空间，足够使用，如果每次都将图片上传到七牛图床，然后粘贴链接，步骤非常的繁琐， ​ 因此尝试寻找自动粘贴后变成链接的工具。 ​ 在知乎的问答中： ​ 找到一个插件 hexo-admin-qiniu，可以方便图片的插入。可以按照如下的步骤来进行： ​ 步骤1：在七牛中建立一个存储空间（Bucket），地区一定要选择华东！一定要选择华东！一定要选择华东！，如下所示： ​ ​ 图中的标记部分，在后序会用到：BucketHost ​ 步骤2:安装 hexo-admin-qiniu插件 ​ 按照如下的教程，安装好插件：http://lazyboy.site/hexo-admin-qiniu/ ​ 在根config文件中，配置好七牛的图床，一个参考的配置如下： 1234567admin: qiniuCfg: imageslim: true # 启动图片瘦身，仅华东区bucket可以使用 AccessKey: 'qS-9v53dFGLjk8KVoyFpx587inU36quVSE4jl2-V' SecretKey: 'cM_HQcu17tXg8jVoP07i0UiuxifmiDmJSdUxZHvc' BucketName: 'blogmd' bucketHost: 'pogngdcwy.bkt.clouddn.com' ​ ​ 步骤3:启动服务，在Windows中可以直接访问hexo-admin。 ​ 在hexo-admin中，随意打开一篇文章，将图片粘贴，则会自动生成一个链接，在MarkDown编辑器中，直接粘贴此链接即可。 ​ ​ 同时，在七牛的后台可以看到刚才操作中产生的图片： ​","tags":[]}]