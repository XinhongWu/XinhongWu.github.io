[{"title":"PLSQL Cursor使用方法研究","date":"2019-04-12T09:40:56.000Z","path":"2019/04/12/PLSQL-Cursor使用方法研究/","text":"PLSQL Cursor使用方法研究1 Cursor的基本操作1) Cursor Declare A cursor is a SELECT statement that is defined within the declaration section of your PLSQL code. We’ll take a look at three different syntaxes to declare a cursor. 游标是在PLSQL的声明部分定义的，表示一个Select Statement 最简单的不带参数的Cursor定义如下： 1234&gt; &gt; CURSOR cursor_name&gt; &gt; IS&gt; &gt; SELECT_statement;&gt; &gt; 同时，也存在带参数的Cursor，游标的参数只能是入参，如下所示： 123456&gt; &gt; CURSOR c2 (subject_id_in IN varchar2)&gt; &gt; IS&gt; &gt; SELECT course_number&gt; &gt; FROM courses_tbl&gt; &gt; WHERE subject_id = subject_id_in;&gt; &gt; 同时，Cursor还可以指定返回类型： 123456CURSOR c3RETURN courses_tbl%ROWTYPEIS SELECT * FROM courses_tbl WHERE subject = &apos;Mathematics&apos;; 2) Open CursorOnce you’ve declared your cursor, the next step is to use the OPEN statement to open the cursor. 当声明cursor后，下一步就是使用open语句打开。 示例如下： 1234567891011121314151617181920212223242526CREATE OR REPLACE Function FindCourse ( name_in IN varchar2 ) RETURN numberIS cnumber number; CURSOR c1 IS SELECT course_number FROM courses_tbl WHERE course_name = name_in;BEGIN OPEN c1; FETCH c1 INTO cnumber; if c1%notfound then cnumber := 9999; end if; CLOSE c1;RETURN cnumber;END; 注意：打开游标的目的是执行Select语句： 就是执行游标所对应的SELECT 语句，将其查询结果放入工作区，并且指针指向工作区的首部，标识游标结果集合。 如果游标查询语句中带有FOR UPDATE选项，OPEN 语句还将锁定数据库表中游标结果集合对应的数据行。 3) Fetch CursorThe purpose of using a cursor, in most cases, is to retrieve the rows from your cursor so that some type of operation can be performed on the data. After declaring and opening your cursor, the next step is to use the FETCH statement to fetch rows from your cursor. 使用游标的目的，在大多数的情况下，是提取游标中的row数据，来使得一些操作类型能够在数据上执行。在声明、打开游标之后，下一步是fetch数据。 fetch数据是指检索集合中的数据行，放入指定的输出变量中。 在执行fetch语句时，需要注意： 执行FETCH语句时，每次返回一个数据行，然后自动将游标移动指向下一个数据行。当检索到最后一行数据时，如果再次执行FETCH语句，将操作失败，并将游标属性%NOTFOUND置为TRUE。所以每次执行完FETCH语句后，检查游标属性%NOTFOUND就可以判断FETCH语句是否执行成功并返回一个数据行，以便确定是否给对应的变量赋了值。 4) Close CursorThe final step of working with cursors is to close the cursor once you have finished using it. 完成Cursor的使用后，最后一步是close游标。 2 Cursor 的使用技巧游标，提供了一种对具有多行数据查询结果集中的每一行数据分别进行单独处理的方法，是设计嵌入式SQL语句的应用程序的常用编程方式。 SQL语句 游标 非查询语句 隐式的 结果是单行的查询语句 隐式的或显示的 结果是多行的查询语句 显示的 从上表看出，显式的游标只在查询语句中出现。 在前小节中出现的4个步骤，都是指显式游标的处理过程，与前一小节的Select Statement对应起来了。 1) cursor不带参数的遍历方法cursor存在几个重要的属性： 123456789Cursor_name%FOUND 布尔型属性，当最近一次提取游标操作FETCH成功则为 TRUE,否则为FALSE；Cursor_name%NOTFOUND 布尔型属性，与%FOUND相反；Cursor_name%ISOPEN 布尔型属性，当游标已打开时返回 TRUE；Cursor_name%ROWCOUNT 数字型属性，返回已从游标中读取的记录数。Cursor_name%ROWTYPE 游标记录类型 因此，可以使用FOUND标记来遍历多行的数据，示例的PLSQL的代码如下： 1234567891011121314151617181920-- Created on 2019/4/12 by CLARK declare cursor c_cursor is select eno || salary,sales from employee; v_ename employee.Partment%type; v_sales employee.Sales%type;begin open c_cursor; fetch c_cursor into v_ename,v_sales; while c_cursor%FOUND loop dbms_Output.put_line(c_cursor%ROWCOUNT); DBMS_OUTPUT.PUT_LINE(v_ename||&apos;---&apos;||to_char(v_sales) ); fetch c_cursor into v_ename,v_sales; end loop; if c_cursor%ISOPEN then dbms_Output.put_line(&apos;true&apos;); else dbms_Output.put_line(&apos;false&apos;); end if; close c_cursor;end; 2) cursor带参数的遍历方法cursor 带参数时，参数将作用于Select Statement，如下所示： 123456789101112131415161718declare cursor cur(start_salary in number) is select eno,salary from employee where salary &gt; start_salary; v_eno number; v_salary number;begin open cur(400); loop fetch cur into v_eno,v_salary; exit when cur%NOTFOUND; update employee set salary = salary - 11 where eno = v_eno; commit; end loop; exception when others then dbms_output.put_line(&apos;exception&apos;);end; 可以使用游标来定义变量，比声明Record的方式要安全和方便，不易出错：通过使用Cursor的属性：ROWTYPE。 如下的方式： 1234567891011121314151617declare cursor cur(start_salary in number) is select eno,salary from employee where salary &gt; start_salary; e_record cur%ROWTYPE;begin open cur(400); loop fetch cur into e_record; exit when cur%NOTFOUND; update employee set salary = e_record.salary - 11 where eno = e_record.eno; commit; end loop; exception when others then dbms_output.put_line(&apos;exception&apos;);end; 3) cursor 带参数且有返回值的用法注意：尚未明确返回值的使用方法，本例的参考如下： 12345678910111213141516171819202122232425DECLARE TYPE emp_record_type IS RECORD( f_name employees.first_name%TYPE, h_date employees.hire_date%TYPE); v_emp_record EMP_RECORD_TYPE; CURSOR c3(dept_id NUMBER, j_id VARCHAR2) --声明游标,有参数有返回值 RETURN EMP_RECORD_TYPE IS SELECT first_name, hire_date FROM employees WHERE department_id = dept_id AND job_id = j_id;BEGIN OPEN c3(j_id =&gt; &apos;AD_VP&apos;, dept_id =&gt; 90); --打开游标,传递参数值 LOOP FETCH c3 INTO v_emp_record; --提取游标 IF c3%FOUND THEN DBMS_OUTPUT.PUT_LINE(v_emp_record.f_name||&apos;的雇佣日期是&apos; ||v_emp_record.h_date); ELSE DBMS_OUTPUT.PUT_LINE(&apos;已经处理完结果集了&apos;); EXIT; END IF; END LOOP; CLOSE c3; --关闭游标END; 3 Cursor For 循环1）标准的针对游标For循环PLSQL提供了游标For循环语句，自动执行Open，Fetch，Close操作。 当进入循环时，游标FOR循环语句自动打开游标，并提取第一行游标数据，当程序处理完当前所提取的数据而进入下一次循环时，游标FOR循环语句自动提取下一行数据供程序处理，当提取完结果集合中的所有数据行后结束循环，并自动关闭游标。 格式如下： 123FOR index_variable IN cursor_name[(value[, value]…)] LOOP -- 游标数据处理代码 END LOOP; index_variable 为游标FOR循环语句隐含声明的索引变量，可以认为是记录变量，其结构与游标查询语句返回的结构集合的结构相同。 可以通过index_variable来提取游标数据。 12345678910111213declare cursor cur(start_salary in number) is select eno,salary from employee where salary &gt; start_salary; e_record cur%ROWTYPE;begin for index_record in cur(200) Loop update employee set salary = index_record.salary - 11 where eno = index_record.eno; commit; end loop; exception when others then dbms_output.put_line(&apos;exception&apos;);end; 注意：如果在游标查询语句的选择列表中存在计算列，则必须要为其指定别名后才能通过游标FOR循环语句的索引访问。 例如在下面的例子中，需要进行统计行数： 1234567891011declare cursor cur is select count(1) as cnt from employee where salary &gt; 300;begin for index_record in cur Loop dbms_output.put_line(index_record.cnt); end loop;exception when others then dbms_output.put_line(&apos;exception&apos;);end; 在游标的定义语句中，使用select count(1) as cnt来重命名，目的是为了在下面引用时可以访问到。 12 2）子查询使用在游标For循环12345BEGIN FOR c1_rec IN(SELECT department_name, location_id FROM departments) LOOP DBMS_OUTPUT.PUT_LINE(c1_rec.department_name||&apos;---&apos;||c1_rec.location_id); END LOOP;END;","tags":[]},{"title":"MySQL/Oracle DDL&&DML 温故知新","date":"2019-04-11T06:21:26.000Z","path":"2019/04/11/DML-DDL/","text":"MySQL DDL&amp;&amp;DML 温故知新1 DDL in SQL数据库定义语言。SQL的命令可以划分为四大类型： DDL(Data Definition Language) : DDL or Data Definition Language actually consists of the SQL commands that can be used to define the database schema. It simply deals with descriptions of the database schema and is used to create and modify the structure of database objects in database. Examples of DDL commands: CREATE – is used to create the database or its objects (like table, index, function, views, store procedure and triggers). DROP – is used to delete objects from the database. ALTER-is used to alter the structure of the database. TRUNCATE–is used to remove all records from a table, including all spaces allocated for the records are removed. COMMENT –is used to add comments to the data dictionary. RENAME –is used to rename an object existing in the database. DML(Data Manipulation Language) : The SQL commands that deals with the manipulation of data present in database belong to DML or Data Manipulation Language and this includes most of the SQL statements. Examples of DML: SELECT – is used to retrieve data from the a database. INSERT – is used to insert data into a table. UPDATE – is used to update existing data within a table. DELETE – is used to delete records from a database table. DCL(Data Control Language) : DCL includes commands such as GRANT and REVOKE which mainly deals with the rights, permissions and other controls of the database system. Examples of DCL commands: GRANT-gives user’s access privileges to database. REVOKE-withdraw user’s access privileges given by using the GRANT command. TCL(transaction Control Language) : TCL commands deals with the transaction within the database . Examples of TCL commands: COMMIT– commits a Transaction. ROLLBACK– rollbacks a transaction in case of any error occurs. SAVEPOINT–sets a savepoint within a transaction. SET TRANSACTION–specify characteristics for the transaction. DDL 主要是用来创建和修改database结构，例如表、字段、数据库的结构的修改等。 2 create table definecreate table的经典格式为： 12345678910111213root@host# mysql -u root -pEnter password:*******mysql&gt; use TUTORIALS;Database changedmysql&gt; CREATE TABLE tutorials_tbl(-&gt; tutorial_id INT NOT NULL AUTO_INCREMENT,-&gt; tutorial_title VARCHAR(100) NOT NULL,-&gt; tutorial_author VARCHAR(40) NOT NULL,-&gt; submission_date DATE,-&gt; PRIMARY KEY ( tutorial_id )-&gt; );Query OK, 0 rows affected (0.16 sec)mysql&gt; 查看表的定义时，会发现实际有如下的字段： 1234567CREATE TABLE `tutorials_tbl` ( `tutorial_id` int(11) NOT NULL AUTO_INCREMENT, `tutorial_title` varchar(100) NOT NULL, `tutorial_author` varchar(40) NOT NULL, `submission_date` date DEFAULT NULL, PRIMARY KEY (`tutorial_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 由此，可以看出：一个完整的数据库表的定义，应该包括： 表名 、列定义 、 完整性约束 、引擎定义 其中完整性约束与引擎定义在实际的字段中并非必要选项。 3 完整性约束主键、外键、索引 （Key的特征）默认、自增、非空 (Value 特征） PRIMARY KEY (PK) 标识该字段为该表的主键，可以唯一的标识记录FOREIGN KEY (FK) 标识该字段为该表的外键NOT NULL 标识该字段不能为空UNIQUE KEY (UK) 标识该字段的值是唯一的AUTO_INCREMENT 标识该字段的值自动增长（整数类型，而且为主键）DEFAULT 为该字段设置默认值 UNSIGNED 无符号ZEROFILL 使用0填充 在完整性约束中，存在一个核心的问题： Primary Key VS Unique Index？ 一个经典的回答如下： 1234Note that “primary” is called PRIMARY KEY not INDEX. KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …) INDEX is something on the physical level, helps improve access time for table operations. Behind every PK there is (usually) unique index created (automatically). Key 是数据库理论中的概念，是逻辑设计层面的。 Index 是实实在在的数据库对象，占用了存储空间，是物理实现层面的。 在多种场景下，二者的概念可以混用。 各种不同的Key设计，需要Index来具体实现。 在StackOverFlow中有一个Issue专门描述二者的区别： https://stackoverflow.com/questions/487314/primary-key-or-unique-index 简而言之： 共同点：A primary Key implies a unique index. 不同点： A primary key also implies NOT NULL, but a unique index can be nullable. There can be only one primary key, but there can be multiple unique indexes. If there is no clustered index defined then the primary key will be the clustered index. Primary Key 是 Unique Index 的特殊形式。 4 CHARSET 与 COLLATE在定义引擎时，会有如下的字段： 1ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 如果不指定，则会使用默认值。 CHARSET与COLLATE的关系： 123456789A character set is a set of symbols and encodings. A collation is a set of rules for comparing characters in a character set. Let's make the distinction clear with an example of an imaginary character set.Suppose that we have an alphabet with four letters: A, B, a, b. We give each letter a number: A = 0, B = 1, a = 2, b = 3. The letter A is a symbol, the number 0 is the encoding for A, and the combination of all four letters and their encodings is a character set.Suppose that we want to compare two string values, A and B. The simplest way to do this is to look at the encodings: 0 for A and 1 for B. Because 0 is less than 1, we say A is less than B. What we've just done is apply a collation to our character set. The collation is a set of rules (only one rule in this case): “compare the encodings.” We call this simplest of all possible collations a binary collation.But what if we want to say that the lowercase and uppercase letters are equivalent? Then we would have at least two rules: (1) treat the lowercase letters a and b as equivalent to A and B; (2) then compare the encodings. We call this a case-insensitive collation. It is a little more complex than a binary collation.In real life, most character sets have many characters: not just A and B but whole alphabets, sometimes multiple alphabets or eastern writing systems with thousands of characters, along with many special symbols and punctuation marks. Also in real life, most collations have many rules, not just for whether to distinguish lettercase, but also for whether to distinguish accents (an “accent” is a mark attached to a character as in German Ö), and for multiple-character mappings (such as the rule that Ö = OE in one of the two German collations). 通过上述的这段描述，可以看出： CHARSET 是定义字符的编码集合，COLLATE 是定义字符的比较规则。 COLLATE会影响到ORDER BY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响`DISTINCT、GROUP BY、HAVING语句的查询结果。 通常，每种CharSet都有其所支持的COLLATE，每种CHARSET都会指定默认的COLLATE。 例如Latin1编码的默认COLLATE为latin1_swedish_ci，GBK编码的默认COLLATE为gbk_chinese_ci，utf8mb4编码的默认值为utf8mb4_general_ci 5 Distinct column1，columndistinct的作用是去重。当选择一列时，去重是很好理解的，将这一列中的重复元素进行去除。 那么当distinct后面接2个column甚至更多，将会如何进行去重呢？ 答案：将(column1，column2 ) 看做是一个二元的向量，进行去重。例如： 原始的表的数据为： 执行命令： 1select distinct sname,grade from student; 得到的结果如下： sname出现了2次。 6 Where 子句 Between、InBetween子句的用法如下： 123SELECT column_name(s)FROM table_nameWHERE column_name BETWEEN value1 AND value2; value的值可以是text、date、number。 注意，对于date，可以直接进行比较，如下： 123select * from student where birth between'1988-09-10' and '1988-09-20' ; IN operator allows you to easily test if the expression matches any value in the list of values. It is used to remove the need of multiple OR condition in SELECT, INSERT, UPDATE or DELETE. You can also use NOT IN to exclude the rows in your list. IN以及NOT IN的作用相当于是黑名单与白名单。 示例的查询代码如下： 1234&gt; &gt; SELECT column_name(s)&gt; &gt; FROM table_name&gt; &gt; WHERE column_name IN (list_of_values);&gt; &gt; 关于between与in的用法可以参考：https://www.geeksforgeeks.org/sql-between-in-operator/ 6 Order by The ORDER BY statement in sql is used to sort the fetched data in either ascending or descending according to one or more columns. By default ORDER BY sorts the data in ascending order. We can use the keyword DESC to sort the data in descending order and the keyword ASC to sort in ascending order. order by 可以根据一行，也可以根据多行。 Sort according to multiple columns: To sort in ascending or descending order we can use the keywords ASC or DESC respectively. To sort according to multiple columns, separate the names of columns by (,) operator. Syntax: 12&gt; &gt; &gt;SELECT * FROM table_name ORDER BY column1 ASC|DESC , column2 ASC|DESC&gt; &gt; &gt; 对于上面的子句，首先按照column1进行排序，对于column1中的相同部分再按照column2中的内容进行排序。 order by字段可以参考：https://www.geeksforgeeks.org/sql-order-by/ 7 Select TOP并非所有的数据库都支持Select top（MS_SQL支持），MySQL可以用limit来达到，Oracle使用 ROWNUM 虚拟列 特别说下Oracle，对于虚拟列，与order by结合在一起使用时，需要特别注意，有时可能得不到想要的结果。 对于Select Top N的操作，可以直接使用： 1Select * from table_name where rownum &lt;= N rownum从1开始。如果要查询第M行到N行的数据，需要使用子查询。 或者，当rownum与order by 混合使用时，如果直接使用： 1SELECT * FROM employees WHERE ROWNUM &lt; 11 ORDER BY last_name; 可能每次都会生成不同的结果，正确的使用方法是： 123SELECT * FROM (SELECT * FROM employees ORDER BY employee_id) WHERE ROWNUM &lt; 11; 详细参考：https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns009.htm 8 LIKE CLAUSElike的使用语法如下： 123SELECT column_name(s)FROM table_nameWHERE column_name LIKE pattern; like的模式匹配中，通常可以有如下的2个符号： 12345The pattern can contain special pattern-matching characters:An underscore (_) in the pattern matches exactly one character (as opposed to one byte in a multibyte character set) in the value.A percent sign (%) in the pattern can match zero or more characters (as opposed to bytes in a multibyte character set) in the value. The pattern '%' cannot match a null. 关于Like的更多用法（设置转义字符等等），请参考官方的文档： https://docs.oracle.com/cd/B13789_01/server.101/b10759/conditions016.htm 9 别名 Alias对于MySQL来说，使用AS，来起到别名的作用。 存在表别名与列的别名。 在Oracle的帮助文档中： 1234Oracle ALIASES can be used to create a temporary name for columns or tables.COLUMN ALIASES are used to make column headings in your result set easier to read.TABLE ALIASES are used to shorten your SQL to make it easier to read or when you are performing a self join (ie: listing the same table more than once in the FROM clause). 列的别名使得查询结果更加易读。表的别名，可以使得SQL语句更加简短尤其是当实现Self Join。 12column_name AS alias_nametable_name alias_name 在Oracle中，实际在测试中发现，对于表，不能加as，对于列，可以加可不加。 需要注意的几个事项： If the alias_name contains spaces, you must enclose the alias_name in quotes. It is acceptable to use spaces when you are aliasing a column name. However, it is not generally good practice to use spaces when you are aliasing a table name. The alias_name is only valid within the scope of the SQL statement. 别名只在当前的SQL语句中有效。 例如： 123SELECT contact_id, first_name || last_name AS NAMEFROM contactsWHERE last_name = 'Anderson'; 表的别名在表Join时应用更加凸显： 12345SELECT p.product_id, p.product_name, categories.category_nameFROM products pINNER JOIN categoriesON p.category_id = categories.category_idORDER BY p.product_name ASC, categories.category_name ASC; 参考如下的连接：https://www.techonthenet.com/oracle/alias.php 10 JOIN联表查询There are 4 different types of Oracle joins: Oracle INNER JOIN (or sometimes called simple join) Oracle LEFT OUTER JOIN (or sometimes called LEFT JOIN) Oracle RIGHT OUTER JOIN (or sometimes called RIGHT JOIN) Oracle FULL OUTER JOIN (or sometimes called FULL JOIN) Inner Join：根据联合条件，选择两表中的共有的value。 在实际操作时，需要注意排列组合的实现：表 hobby的数据如下： 表 lessons的数据如下： 执行的联表的语句为： 1select h.sname,h.hoby,l.lesson from hobby h inner join lessons l on h.sname = l.sname; 输出的结果为： 由此可以推知：Inner Join会以内联字段作为桥梁，进行排列组合式的联结。 Left Join：左联。LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 Right Join: 右联。RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 左联与右联主要差别在于，以哪张表为基础，去另外一张表中寻找数据。注意，在寻找数据时，不是一一对应的关系，也可能出现排列组合的方式。 FULL JOIN：全联结。相当于左联结与右联结的并集。 11 Union &amp;&amp; Union ALLUnion用于将不同的查询结果进行合并： 请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 Union 与 union all的区别在于，union相当于distinct，而union all是包含重复的项。 12 Select intoSelect into 语句从1个或者多个数据库表中获取数据，并且将select的值分配到变量或者集合。 In its default usage (SELECT ... INTO), this statement retrieves one or more columns from a single row In its bulk usage (SELECT ... BULK COLLECT INTO), this statement retrieves an entire result set at once. 默认select into从单行中截取数据，可以截取多列，如果有多行的数据返回，则会报错：TOO_MANY_ROWS，例如下格式： 123456789select sname,sno into l_name,l_cnt from student where sno = 9527;select * into l_cnt，l_name from student where sno = 9527;TYPE stu_record IS RECORD( SNO NUMBER, Name VARCHAR2(32) );rec1 stu_record;select * into rec1 from student where sno = 9527; 使用select into时，需要注意异常的捕捉： 一个参考的例子如下： 1234567891011121314151617181920declare TYPE stu_record IS RECORD( SNO NUMBER, Name VARCHAR2(32) ); l_cnt number := 0; l_name varchar2(32) := &apos;&apos;; rec1 stu_record; begin select * into rec1 from student where sno = 9910; dbms_output.put_line(rec1.SNO || &apos; is the number of lines&apos; || rec1.Name);exception when no_data_found or too_many_rows then dbms_output.put_line(&apos;error found&apos;); when others then dbms_output.put_line(&apos;other error found&apos;);end; If no rows are returned, PL/SQL raises NO_DATA_FOUND. You can guard against this exception by selecting the result of an aggregate function, such as COUNT(*) or AVG(), where practical. These functions are guaranteed to return a single value, even if no rows match the condition. 对于 SELECT ... BULK COLLECT INTO ,返回的是多行数据吗，需要set up集合变量来存储结果，You can declare associative arrays or nested tables that grow as needed to hold the entire result set. 13 存储过程 调试方法直接在SQL窗口中，是无法进行调试的，需要进入到“测试窗口”才可以进行，即使是存储过程和包，都是需要进入到测试窗口。 进入测试窗口的方法：“新建”–》“测试窗口”。调试时，可以看到调试输出信息。 如果提示：ORA-0131 :insufficient privileges DEBUG CONNECT SESSION 则表示当前的用户没有Debug权限，则需要使用系统用户进行授权，授权的脚本为： 1grant DEBUG CONNECT SESSION to scott 14 SQL Subqueries(子查询)1In Oracle, a subquery is a query within a query. You can create subqueries within your SQL statements. These subqueries can reside in the WHERE clause, the FROM clause, or the SELECT clause. 子查询即查询中的查询。可以驻留在where、from、select子句中。 在Where子句中，是最常见的场景 nested subqueries： 12345SELECT * FROM all_tables tabsWHERE tabs.table_name IN (SELECT cols.table_name FROM all_tab_columns cols WHERE cols.column_name = &apos;SUPPLIER_ID&apos;); Oracle allows up to 255 levels of subqueries in the WHERE clause. from子句中的场景： 123456SELECT suppliers.name, subquery1.total_amtFROM suppliers, (SELECT supplier_id, SUM(orders.amount) AS total_amt FROM orders GROUP BY supplier_id) subquery1WHERE subquery1.supplier_id = suppliers.supplier_id; 这又被叫做 inline views，与inner join异曲同工。 12select student.sname,hobby.shobby from student,hobby where student.sno = hobby.snoselect student.sname,hobby.shobby from student inner join hobby on student.sno = hobby.sno; Select 子句场景： 12345SELECT tbls.owner, tbls.table_name, (SELECT COUNT(column_name) AS total_columns FROM all_tab_columns cols WHERE cols.owner = tbls.owner AND cols.table_name = tbls.table_name) subquery2 The subquery has been aliased with the name subquery2. This will be the name used to reference this subquery or any of its fields. The trick to placing a subquery in the select clause is that the subquery must return a single value. This is why an aggregate function such as SUM function, COUNT function, MIN function, or MAX function is commonly used in the subquery. 如果要在select 子句中添加子句，要保证返回的值是一个单个的值。 15 Collection 集合学习参考：https://www.tutorialspoint.com/plsql/plsql_collections.htm https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/05_colls.htm#20425 PLSQL有3种类型的集合。 PL/SQL provides three collection types Index-by tables or Associative array Nested table Variable-size array or Varray 16 From table to table1）INSERT INTO SELECT 从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。 在插入时，要需要注意待插入表的约束的情况。示例的一个插入语句如下： 1insert into student select * from STUDENT_BAK b where b.sno not in (select sno from student) 2) create table as select 新建的表要求不存在，创建一个新表，从一个表中的数据复制另外一个表中的数据。但是这种方式只会保留数据，表的约束并不会同步过来。 1create table student_bak as select * from STUDENT t; 17 View视图参考如下的连接：https://www.techonthenet.com/oracle/views.php View与Table的区别点摘抄如下： 区别： ​ 1、视图是已经编译好的sql语句。而表不是​ 2、视图没有实际的物理记录。而表有。​ 3、表是内容，视图是窗口​ 4、表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改​ 5、表是内模式，视图是外模式​ 6、视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。​ 7、表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。 ​ 8、视图的建立与删除只影响视图本身，不影响对应的基本表。 联系：视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。 ​ 一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。 在普通用户下创建view时，会提示权限不足，可以使用如下的指令在sysdba模式下授权： 1grant create view to scott View的创建： 1234CREATE VIEW view_name AS SELECT columns FROM tables [WHERE conditions]; ​ where语句是可选的，其条件必须要被view_name中的视图所满足。 View的更新： 可以在不drop view的前提下更新一个Oracle的View的定义。 123456CREATE or REPLACE VIEW sup_orders AS SELECT suppliers.supplier_id, orders.quantity, orders.price FROM suppliers INNER JOIN orders ON suppliers.supplier_id = orders.supplier_id WHERE suppliers.supplier_name = &apos;Apple&apos;; 这句话的命令是不存在则创建，存在则更新一个View。 如果直接更新一个view，可能会影响到实际的数据。 Question: Can you update the data in an Oracle VIEW? Answer: A VIEW in Oracle is created by joining one or more tables. When you update record(s) in a VIEW, it updates the records in the underlying tables that make up the View. So, yes, you can update the data in an Oracle VIEW providing you have the proper privileges to the underlying Oracle tables. View的删除： 1DROP VIEW sup_orders; 注意，删除了view，这个view所依赖的表不会有影响。类似的，删除了表，这个view依旧会存在，只是在使用时会提示数据错误问题。 18 函数Oracle标准的内建函数参见如下的列表： https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj55788.html 聚合函数：Aggregates (set functions)： https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj33923.html 19 Group by参考链接：https://www.techonthenet.com/oracle/group_by.php The Oracle GROUP BY clause is used in a SELECT statement to collect data across multiple records and group the results by one or more columns. group by经常与聚合函数一起使用。In this case, the aggregate function returns the summary information per group。在此情况下，聚合函数返回的是每个组的sum信息。 The GROUP BY clause must contain only aggregates or grouping columns. group by只能包含聚合的列。 Group By有一个比较好的作用，在于去重。 1select sno,sname from stu_bak group by sno, sname 通用的一个Group by的表达式为： 12345SELECT expression1, expression2, ... expression_n, aggregate_function (aggregate_expression)FROM tables[WHERE conditions]GROUP BY expression1, expression2, ... expression_n; 注意几个约束条件： 1）The expressions that are not encapsulated within an aggregate function and must be included in the GROUP BY clause 未出现在聚合函数中的expression必须要包含在group by子句中。 2）aggregate_function It can be a function such as SUM, COUNT, MIN, MAX, or AVG functions. 3）aggregate_expression：This is the column or expression that the aggregate_function will be used on. 4）tables：The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause. 5）WHERE conditions：Optional. The conditions that must be met for the records to be selected. Group中aggregate_function可以认为是对group分组的操作，如下所示： 1select sname,count(*) from stu_bak group by sname; 此处的count()并非是整个表的数量，上述的语句的含义为：按照sname进行分组，并对分组执行count(\\)，统计分组的数量。 20 Having子句having子句需要与Group by一起使用，作用是对group的分组再次进行筛选。 只对聚合的结果进行筛选。 The Oracle HAVING clause is used in combination with the GROUP BY clause to restrict the groups of returned rows to only those whose the condition is TRUE. 使用的方法如下： 123456SELECT expression1, expression2, ... expression_n, aggregate_function (aggregate_expression)FROM tables[WHERE conditions]GROUP BY expression1, expression2, ... expression_nHAVING having_condition; 在Group by的约束后，又增加了如下的一个： having_condition：This is a further condition applied only to the aggregated results to restrict the groups of returned rows. Only those groups whose condition evaluates to TRUE will be included in the result set. 是对聚合的结果的约束加强。示例的脚本： 1select partment,sum(salary) from EMPLOYEE t group by partment having sum(sales)&gt;=30 ;","tags":[]},{"title":"TCP、UDP、Port、Socket 温故知新","date":"2019-03-25T08:17:45.000Z","path":"2019/03/25/TCP/","text":"TCP、UDP、Port、Socket 温故知新0.序本文主要参考：http://www.steves-internet-guide.com/tcpip-ports-sockets/ 是迄今见过讲解最易懂的文章。 1 TCP、UDP的区别TCP与UDP是传输层的协议，其上一层是应用层。 在package层面，TCP与UDP的封包的头有所不同。 在很多资料中，都有提到TCP与UDP的区别： 1） TCP的特征 其中，对于“Connection-Oriented”的理解，参考WIki百科（https://en.wikipedia.org/wiki/Connection-oriented_communication）： Connection-oriented communication is a network communication mode in telecommunications and computer networking, where a communication session or a semi-permanent connection is established before any useful data can be transferred, and where a stream of data is delivered in the same order as it was sent[citation needed]. 面向连接的通信方式在数据传输之前，需要先establish a connection。这也就意味着，在 1netstat -ano 命令查看到的连接，将是TCP的连接。 一个输出结果示例： 12345678910111213141516171819202122232425262728C:\\Users\\Clark&gt;netstat -ano活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 524 TCP 0.0.0.0:443 0.0.0.0:0 LISTENING 6748 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:902 0.0.0.0:0 LISTENING 4972 TCP 0.0.0.0:912 0.0.0.0:0 LISTENING 4972 TCP 0.0.0.0:5040 0.0.0.0:0 LISTENING 7236 TCP 0.0.0.0:5357 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:11301 0.0.0.0:0 LISTENING 6692 TCP 0.0.0.0:20831 0.0.0.0:0 LISTENING 8788 TCP 0.0.0.0:49664 0.0.0.0:0 LISTENING 648 TCP 0.0.0.0:49665 0.0.0.0:0 LISTENING 1544 TCP 0.0.0.0:49666 0.0.0.0:0 LISTENING 1768 TCP 0.0.0.0:49667 0.0.0.0:0 LISTENING 2896 TCP 0.0.0.0:49668 0.0.0.0:0 LISTENING 3188 TCP 0.0.0.0:49669 0.0.0.0:0 LISTENING 796 TCP 0.0.0.0:49708 0.0.0.0:0 LISTENING 772 TCP 0.0.0.0:50054 0.0.0.0:0 LISTENING 13104 TCP 127.0.0.1:443 127.0.0.1:52734 ESTABLISHED 6748 TCP 127.0.0.1:443 127.0.0.1:53039 ESTABLISHED 6748 TCP 127.0.0.1:4300 0.0.0.0:0 LISTENING 13104 TCP 127.0.0.1:4301 0.0.0.0:0 LISTENING 13104 TCP 127.0.0.1:5939 0.0.0.0:0 LISTENING 3720 TCP 172.254.40.135:53702 172.20.30.83:3389 ESTABLISHED 22664 从上图可以看出，本机的一些端口处于侦听状态（Listening），有些端口处于连接状态（Established）。 例如最后一行，172.254.40.135作为客户端连接到172.20.30.183的3389端口。 通过数字的大小，可以初步判断相对应的客户端和服务端。 2） UDP的特征 UDP是一种Try Best Effort尽力传输的方式，不保证数据的可靠传输，丢了就丢了。 在传输之前，是不需要事先建立连接的。 UDP适用于传输少量数据，对于可靠性要求不高的环境，例如ping来检查网络的连通性，发送的就是UDP报文。 且因为UDP不需要握手建立连接以及ACK确认包的传输情况，所以传输速度很快，例如QQ传文件使用的就是UDP。 TCP适用于传输大量的数据，且对可靠性要求较高的环境。 2 Port 端口分布特征首先思考一个问题：为什么要有端口？ 为什么光有IP地址不行？ IP地址相当于是网络中的计算机的身份中，是用来进行身份识别的标记。 如果主机中运行了多个应用程序，客户端将如何识别这些不同的服务呢？这个时候，采用的是端口的机制。 引用一段描述： The use of ports allow computers/devices to run multiple services/applications*.* TCP/IP协议的端口是有其特征的： 服务端与客户端的端口的使用是有差异的，对于服务器端而言，一般使用的是永久的端口，不会随着请求的变化而变化，而客户端而言，使用的是临时端口 TCP与UDP在Header中，有2个字节标志Port Number，因此其范围是0~65535 一般情况下，服务端的端口需要被广而告之，这样客户端才能使用其服务。 关于端口的一段描述如下： Port numbers 0-1023 – Well known ports. These are allocated to server services by the Internet Assigned Numbers Authority (IANA). e.g Web servers normally use port 80 and SMTP servers use port 25 (see diagram above). Ports 1024-49151- Registered Port -These can be registered for services with the IANA and should be treated as semi-reserved. User written programs should not use these ports. Ports 49152-65535– These are used by client programs and you are free to use these in client programs. When a Web browser connects to a web server the browser will allocate itself a port in this range. Also known as ephemeral ports. TCP与UDP的端口号是完全分离的。 一些比较有意思的现象： 有的服务需要占用相同协议的不同端口：FTP TCP/20 (data)，TCP/21 (control) 有的服务不同协议的相同端口：DNS TCP/53（zone transfer）,UDP/53 (client query) 知名的UDP服务端口，包括TFTP、DHCP协议等。 3 Socket的认识精华：Socket = IP + Port A connection between two computers uses a socket. 2台主机之间进行连接，使用的是socket。可以将连接认为是2端的Socket之间的连接。 在许多的编程语言中，Socket也是编程应用的对象。 4 netstat的使用方法Linux和Windows中，都有netstat命令，现在以Windows为例。 对于netstat的命令的使用，参考如下的连接：How to read NETSTAT -AN results 可以看出主机的侦听的端口以及连接的远程端口的情况。","tags":[]},{"title":"VSCode与Git联合使用方法","date":"2019-03-21T05:44:54.000Z","path":"2019/03/21/VSCode与Git联合使用方法/","text":"VSCode与Git联合使用方法1 Git的安装在Windows环境下，可以安装Git的可执行文件来获得Git环境。可以直接Google Git的官网，下载最新版本的程序，按照prompt一一安装即可。 1）git config全局配置123git config --global user.name \"name\"git config --global user.email \"name@qq.com\" 最终配置，将会保存在文件 .gitconfig中。如下: 1234$ cat ~/.gitconfig[user] name = wuxinhong email = wuxinhong@somesite.com.cn 注入其他的全局配置，如http.proxy代理等，都可以使用相类似的方法进行设置。 在指定目录下启动Gitbash的方法为：在窗口区，点击右键，单击Git bash Here 2) git clone URL地址因为公司的码云仓库需要进行鉴权，经过一番摸索后，发现要在 git clone中指定username，才能成功下载代码。 命令的格式如下： 1git clone http://wuxinhong@code.cmschina.com.cn/zdcpkfz/recomsystem.git 本质上，是在原先的HTTP的地址中，增加了username 原始的URL地址是：http://code.cmschina.com.cn/zdcpkfz/recomsystem.git 2 VSCode上库流程1）打开git代码目录下载完Git仓库后，会有一个文件夹.git生成，这个目录将会被VSCode识别。 2）修改代码在VSCode中修改代码后，在工程中将会出现Change提示符号，如下图所示： 3）提交修改提交修改时，可以直接点击提交按钮，会提示添加Commit信息。然后再点击...push到对应的分支，如下图所示： 3 Pull Request的玩法首先需要认识到：git clone下载下来的是全套的代码，包含所有的分支，因此可以使用git checkout branch 来进行分支的切换。 因此，在开发时，切换到dev分支，并且将代码上库到dev分支。然后在GitHub中提起Pull Request。","tags":[]},{"title":"Python 调试技巧","date":"2019-03-20T05:28:57.000Z","path":"2019/03/20/Python-调试技巧/","text":"Python 调试技巧1 pdb 单步跟踪类似Go/C语言的gdb，python也存在一个类似的单步调试器：pdb。 可以使用类似的用法，对Python程序进行调试。 启动pdb调试命令： 1python -m pdb file.py 2 python 函数原型C语言系统API，在Linux下，可以使用man 命令快速的查看函数的原型，例如： man strcpy 12345678910111213141516171819202122232425262728293031323334STRCPY(3) Linux Programmer's Manual STRCPY(3)NAME strcpy, strncpy - copy a stringSYNOPSIS #include &lt;string.h&gt; char *strcpy(char *dest, const char *src); char *strncpy(char *dest, const char *src, size_t n);DESCRIPTION The strcpy() function copies the string pointed to by src, including the terminating null byte ('\\0'), to the buffer pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy. Beware of buffer overruns! (See BUGS.) The strncpy() function is similar, except that at most n bytes of src are copied. Warning: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated. If the length of src is less than n, strncpy() writes additional null bytes to dest to ensure that a total of n bytes are written. A simple implementation of strncpy() might be: char * strncpy(char *dest, const char *src, size_t n) &#123; size_t i; for (i = 0; i &lt; n &amp;&amp; src[i] != '\\0'; i++) dest[i] = src[i]; for ( ; i &lt; n; i++) dest[i] = '\\0'; return dest; &#125; ​ 在Python语言系统中，使用：pydoc ​ 例如，想查看json的dumps接口原型，可以输入：pydoc json.dumps ​ 会有如下的提示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 Help on function dumps in json:json.dumps = dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw) Serialize ``obj`` to a JSON formatted ``str``. If ``skipkeys`` is true then ``dict`` keys that are not basic types (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``) will be skipped instead of raising a ``TypeError``. If ``ensure_ascii`` is false, all non-ASCII characters are not escaped, and the return value may be a ``unicode`` instance. See ``dump`` for details. If ``check_circular`` is false, then the circular reference check for container types will be skipped and a circular reference will result in an ``OverflowError`` (or worse). If ``allow_nan`` is false, then it will be a ``ValueError`` to serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in strict compliance of the JSON specification, instead of using the JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``). If ``indent`` is a non-negative integer, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0 will only insert newlines. ``None`` is the most compact representation. Since the default item separator is ``', '``, the output might include trailing whitespace when ``indent`` is specified. You can use ``separators=(',', ': ')`` to avoid this. If ``separators`` is an ``(item_separator, dict_separator)`` tuple then it will be used instead of the default ``(', ', ': ')`` separators. ``(',', ':')`` is the most compact JSON representation. ``encoding`` is the character encoding for str instances, default is UTF-8. ``default(obj)`` is a function that should return a serializable version of obj or raise TypeError. The default simply raises TypeError. If *sort_keys* is true (default: ``False``), then the output of dictionaries will be sorted by key. To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the ``.default()`` method to serialize additional types), specify it with the ``cls`` kwarg; otherwise ``JSONEncoder`` is used. 3 python 包查找库​ 类似于Go语言的Godoc，Python也有类似的网站：https://pypi.org/ ​ ​","tags":[]},{"title":"Golang json && mysql Data Transfer","date":"2019-03-19T06:02:33.000Z","path":"2019/03/19/Golang-json-mysql-Data-Transfer/","text":"Golang: json &amp;&amp; mysql Data Transfer1 数据流转图​ 在常见的MVC的框架中，涉及到前端UI，后台服务，数据库存储三大块。从编程语言上看，前端使用JavaScript下发JSON数据，后台使用Golang（本项目是Golang）接收前端下发的数据，并将数据存储到MySQL的数据库中。 ​ 整个数据流转关系如下： ​ 2 Client To Server​ UI 层使用的是JSON，支持数字、字符串、布尔型。JSON本身就是JavaScript Object，因此在JS端，所有的数据都是Number、Boolean、String 这三种类型。 ​ 比较幸运，这几种数据类型在常规的编程语言中，都是包含的，如Golang。那么如何来接收从UI端下发的JSON Object，此时需要在Golang中创建一个对应的结构体。 创建1个Struct，建立成员变量名与json目标key的映射关系 JS端下发如下一段JSON： 1234567891011121314&#123; \"network_id\":\"1\", \"network_src_ip\":\"127.0.0.1\", \"network_dst_ip\":\"127.0.0.1\", \"network_dst_port\":3306, \"network_desc\":\"MySQL\", \"network_status\":1, \"network_time_available\":\"2018-07-20T14:42:26+08:00\", \"network_time_unavailable\":\"1970-01-01T08:00:01+08:00\", \"network_group\":0, \"network_alarm_lasttime\":\"1970-01-01T08:00:01+08:00\", \"network_failed_cnt\":0, \"network_disabled\":true&#125; 在Golang中建立如下的结构体，为每个接口体成员打上Tag：JSON Tag中的标签，则表示在JSON中的key 1234567891011121314type PortMonitor struct &#123; ID string `json:\"network_id\"` SrcIP string `json:\"network_src_ip\"` DstIP string `json:\"network_dst_ip\"` DstPort int `json:\"network_dst_port\"` Desc string `json:\"network_desc\"` Status int `json:\"network_status\"` TimeOK time.Time `json:\"network_time_available\"` TimeFail time.Time `json:\"network_time_unavailable\"` Group int `json:\"network_group\"` TimeAlarm time.Time `json:\"network_alarm_lasttime\"` FailCnt int `json:\"network_failed_cnt\"` Disable bool `json:\"network_disabled\"`&#125; json.Unmarshal 完成转换 数据到达服务端时的格式是：[]byte 1234567891011121314151617func CreateProcMonitor(w http.ResponseWriter, r *http.Request, p httprouter.Params) &#123; logger.I(\"call CreateProcMonitor\") res, _ := ioutil.ReadAll(r.Body) uBody := &amp;process.ProcessMonitor&#123;&#125; if err := json.Unmarshal(res, uBody); err != nil &#123; common.SendErrorResponse(w, common.ErrorRequestBodyParseFailed) return &#125; if err := process.DBAddProcMonitorInfo(uBody); err != nil &#123; common.SendErrorResponse(w, common.ErrorDBError) return &#125; common.SendNormalResponse(w, \"Create ProMonitor Info Success\", http.StatusCreated)&#125; 使用函数json:Unmarshal则可以完成JSON结构体向Struct结构体的转换，转换时按照Tag将JSON中的key与Struct中的成员变量名称相对应。 3 Server To DB 从Web服务端调用数据库API执行写库的操作，关键的函数为： 12345678910111213sqlClause := `INSERT INTO network (network_id, network_src_ip, network_dst_ip, network_dst_port, network_desc, network_time_available, network_disabled) VALUES (?, ?, ?, ?, ?, ?, ?)` logger.I(\"sqlClause Insert:%s\", sqlClause) stmtIns, err = dbConn.Prepare(sqlClause) if err != nil &#123; return err &#125; _, err = stmtIns.Exec(portInfo.ID, portInfo.SrcIP, portInfo.DstIP, portInfo.DstPort, portInfo.Desc, portInfo.TimeOK, portInfo.Disable) if err != nil &#123; return err &#125; 核心函数为：stmtIns.Exec 通过实验，证明Exec的参数传递时，支持传统的整型，布尔型，String、time.Time类型等。 4 DB To Server 在数据库中存储的数据，通过接口读取到Go语言中，常用代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func DBGetPortMonitorList(stmt string) ([]*PortMonitor, error) &#123; logger.T(\"Enter Func: DBGetPortMonitorList\") stmtOut, err := dbConn.Prepare(stmt) var res []*PortMonitor if err != nil &#123; return res, err &#125; rows, err := stmtOut.Query() if err != nil &#123; return res, err &#125; defer stmtOut.Close() for rows.Next() &#123; var network_id, network_src_ip, network_dst_ip, network_desc string var network_dst_port, network_status, network_failed_cnt int var network_time_available, network_time_unavailable, network_alarm_lasttime time.Time var network_disabled bool if err := rows.Scan(&amp;network_id, &amp;network_src_ip, &amp;network_dst_ip, &amp;network_dst_port, &amp;network_desc, &amp;network_status, &amp;network_time_available, &amp;network_time_unavailable, &amp;network_alarm_lasttime, &amp;network_failed_cnt, &amp;network_disabled); err != nil &#123; return res, nil &#125; pm := &amp;PortMonitor&#123; ID: network_id, SrcIP: network_src_ip, DstIP: network_dst_ip, DstPort: network_dst_port, Desc: network_desc, Status: network_status, TimeOK: network_time_available, TimeFail: network_time_unavailable, TimeAlarm: network_alarm_lasttime, FailCnt: network_failed_cnt, Disable: network_disabled, &#125; res = append(res, pm) &#125; return res, nil&#125; 获取数据的关键接口是：rows.Scan 通过实验，证明Scan的参数传递时，支持传统的整型，布尔型，String、time.Time类型等。 4 Server To Client 从Golang中将数据返回到客户端，如下代码所示： 1234567891011121314151617181920func GetProcMonitorList(w http.ResponseWriter, r *http.Request, p httprouter.Params) &#123; logger.I(\"call GetProcMonitorList\") stmt := `SELECT id, process_ip, process_name, process_cnt, process_execmd, process_name_find,process_enable_lanch, process_enable_alarm,process_alarm_time,process_groupid,process_switch FROM process` pm, err := process.DBGetProcMonitorList(stmt) if err != nil &#123; logger.E(\"Error When GetProcMonitorList\") common.SendErrorResponse(w, common.ErrorDBError) return &#125; if resp, err := json.Marshal(pm); err != nil &#123; common.SendErrorResponse(w, common.ErrorInternalFaults) return &#125; else &#123; common.SendNormalResponse(w, string(resp), 200) &#125;&#125; 核心的函数是：json.Marshal 这个函数将Struct结构体转变成JSON encode。 通过实验，证明json.Marshal转换后，传递到前端支持传统的整型，布尔型，String、time.Time类型等。 5 time.Time的使用注意事项 对于MySQL的驱动而言，使用Scan方法默认读取到的是[]byte 如果要使得MySQL驱动支持time.Time，需要设置DSN（Data Source Name）parseTime=true。 格式如下： source=root:root@tcp(192.168.133.128:3306)/monitor?loc=Local&amp;parseTime=true&amp;charset=utf8 The default internal output type of MySQL DATE and DATETIME values is []byte which allows you to scan the value into a []byte, string or sql.RawBytes variable in your program. However, many want to scan MySQL DATE and DATETIME values into time.Time variables, which is the logical equivalent in Go to DATE and DATETIME in MySQL. You can do that by changing the internal output type from []byte to time.Time with the DSN parameter parseTime=true. You can set the default time.Time location with the loc DSN parameter. Caution: As of Go 1.1, this makes time.Time the only variable type you can scan DATE and DATETIME values into. This breaks for example sql.RawBytes support. Alternatively you can use the NullTime type as the scan destination, which works with both time.Time and string / []byte. 6 总结 从接口调用的角度： 在设计golang中的结构体时，按照常规的字段的类型声明就可以。 另外，对于time.Time数据类型，要注意NULL默认值，如果数据库中存储的值为NULL，则会提示如下的错误： 1sql: Scan error on column index 6, name \"network_time_available\": unsupported Scan, storing driver.Value type &lt;nil&gt; into type *time.Time","tags":[]},{"title":"Qiniu Image Upload","date":"2019-03-16T13:50:00.000Z","path":"2019/03/16/hello-world/","text":"this article is for uploading imageWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","tags":[]},{"title":"Hexo搭建个人博客站点のSpecil Tips","date":"2019-03-16T06:14:28.000Z","path":"2019/03/16/test-my-site/","text":"Hexo搭建个人博客站点のSpecil Tips1 序言​ Hexo是非常流行的个人站点博客引擎，易学易学，社区教程也非常丰富。 ​ 搭建的教程基本上也是属于手把手级别的，很容易上手。 ​ 本文主要汇总在搭建过程中，自认为比较重要的事项进行记录，方便后续查看。 ​ 关键点： 本文实际采用的网站使用GitHub托管 hexo-admin-qiniu需要结合七牛图床使用 域名解析与CNAME配置文件相结合 2 流程介绍​ 在搭建过程中，主要是参照如下链接： ​ 其中重点参考了从“获得个人网站域名”到“绑定域名”这段过程，主题采用的是BlueLake。 ​ 从选用蓝湖主题开始，参考的是如下的步骤： 3 Special Tips(1) 站点服务器选择​ 国内已经有比较多的云服务器可以选择，如阿里云，腾讯云，华为云等，但是需要注意：如果使用国内的服务器进行网站的搭建，需要对服务器进行许可认证， ​ 即ICP备案。也可以使用国外的服务器，不需要对服务器进行备案。 ​ 本文采用的是vultr服务器，月租相对比较便宜，目前看运行还是比较稳定的。 (2) 每次Deploy时都需要输入密码​ 按照教程，在GitHub的SSH Key的设置界面，将服务器生成的公钥部署完毕。在真正部署时，还是需要输入密码，操作起来非常不便。 ​ 查阅资料后，将根config文件的repo属性进行了如下的更改： 1234deploy: type: git repo: git@github.com:XinhongWu/xinhongwu.github.io.git branch: master ​ 配置完成后，则可以不需要输入密码，即可完成GitHub的推送。 (3) 域名解析CNAME​ 由于网站托管到GitHub上，因此可以使用 github.io格式的网址对网站进行访问。 ​ 对于新申请的域名，需要做一个域名解析的配置，详细配置如下： ​ ​ 需要配置一个CNAME类型和A类型的解析方式。 ​ 光解析到GitHub地址还不够，必须要让GitHub能鉴权通过新注册的域名，因此，需要在博客的source目录下配置一个CNAME文件： ​ ​ 最终会被解析到GitHub的如下位置： ​ (4) 中文标题乱码​ 原因是根config的文件编码格式不是UTF-8，导致推送后显示乱码。 ​ 解决办法：使用Notepad将其编码修改为UTF-8即可。 (5) 设置第三方评论​ 在原生的代码中，有不少的博客评论系统可以选择，如下所示： 12345678910#Cmmentscomment: duoshuo: #chaooo ## duoshuo_shortname disqus: ## disqus_shortname livere: MTAyMC80MzIxNC8xOTc2MA== ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey) ​ 实际发现网易云跟帖已经停止服务了，畅言在申请时需要有网站的备案号，因此本文实际使用的是来必力。 ​ （国外的服务器，不需要在国内备案，畅言可以尝试将没有申请过的备案号输入后申请）。 ​ 注意：来必力的ID可以在data-id中找到，如下所示： ​ (6) 设置代码高亮​ 实际写MD发现，代码并未按照自己的需求高亮，查找资料后发现，还需要额外再添加一个设置： ​ 参考：http://www.mdslq.cn/archives/7266c682.html ​ 在主题config文件中，添加如下的一行： 1highlight_theme: normal (7) 七牛云图片直传​ 七牛云为新用户提供10GB的云存储空间，足够使用，如果每次都将图片上传到七牛图床，然后粘贴链接，步骤非常的繁琐， ​ 因此尝试寻找自动粘贴后变成链接的工具。 ​ 在知乎的问答中： ​ 找到一个插件 hexo-admin-qiniu，可以方便图片的插入。可以按照如下的步骤来进行： ​ 步骤1：在七牛中建立一个存储空间（Bucket），地区一定要选择华东！一定要选择华东！一定要选择华东！，如下所示： ​ ​ 图中的标记部分，在后序会用到：BucketHost ​ 步骤2:安装 hexo-admin-qiniu插件 ​ 按照如下的教程，安装好插件：http://lazyboy.site/hexo-admin-qiniu/ ​ 在根config文件中，配置好七牛的图床，一个参考的配置如下： 1234567admin: qiniuCfg: imageslim: true # 启动图片瘦身，仅华东区bucket可以使用 AccessKey: 'qS-9v53dFGLjk8KVoyFpx587inU36quVSE4jl2-V' SecretKey: 'cM_HQcu17tXg8jVoP07i0UiuxifmiDmJSdUxZHvc' BucketName: 'blogmd' bucketHost: 'pogngdcwy.bkt.clouddn.com' ​ ​ 步骤3:启动服务，在Windows中可以直接访问hexo-admin。 ​ 在hexo-admin中，随意打开一篇文章，将图片粘贴，则会自动生成一个链接，在MarkDown编辑器中，直接粘贴此链接即可。 ​ ​ 同时，在七牛的后台可以看到刚才操作中产生的图片： ​ (8) 设置hexo-admin开机启动​ Ubuntu 18.10与早期的系统有差异，开机启动项目的管理，使用的是Systemd，不再是initd系统。 ​ 配置起来也比较简单，因为存在如下的功能： ​ The rc-local.service already exists in systemd and the service file suggests that the rc.local, if it exists and is executable, gets pulled automatically into multi-user.target ​ 也就是说rc.local将会被系统默认启动。参考链接： ​ https://askubuntu.com/questions/886620/how-can-i-execute-command-on-startup-rc-local-alternative-on-ubuntu-16-10 ​ 示例，在rc.local中添加如下的执行语句： 123#!/bin/bashcd /home/cms/blog;hexo server &amp;exit 0 ​ 然后reboot，则会发现hexo程序在后台执行。 123root@vultr:~# ps -ef | grep hexoroot 645 1 9 21:44 ? 00:00:02 hexoroot 953 936 0 21:44 pts/0 00:00:00 grep --color=auto hexo","tags":[]}]