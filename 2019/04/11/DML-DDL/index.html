<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录个人技术笔记与生活日志"><title>MySQL/Oracle DDL&amp;&amp;DML 温故知新 | 在路上</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL/Oracle DDL&amp;&amp;DML 温故知新</h1><a id="logo" href="/.">在路上</a><p class="description">修心养性，健体强身，终生学习！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">MySQL/Oracle DDL&amp;&amp;DML 温故知新</h1><div class="post-meta"><a href="/2019/04/11/DML-DDL/#comments" class="comment-count"></a><p><span class="date">Apr 11, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h5 id="MySQL-DDL-amp-amp-DML-温故知新"><a href="#MySQL-DDL-amp-amp-DML-温故知新" class="headerlink" title="MySQL DDL&amp;&amp;DML 温故知新"></a>MySQL DDL&amp;&amp;DML 温故知新</h5><h6 id="1-DDL-in-SQL"><a href="#1-DDL-in-SQL" class="headerlink" title="1 DDL in SQL"></a>1 DDL in SQL</h6><p>数据库定义语言。SQL的命令可以划分为四大类型：</p>
<ol>
<li><p>DDL(Data Definition Language) : </p>
<p>DDL or Data Definition Language actually consists of the SQL commands that can be used to define the database schema. It simply deals with descriptions of the database schema and is used to create and modify the structure of database objects in database.</p>
<p><strong>Examples of DDL commands:</strong></p>
<ul>
<li><strong>CREATE</strong> – is used to create the database or its objects (like table, index, function, views, store procedure and triggers).</li>
<li><strong>DROP</strong> – is used to delete objects from the database.</li>
<li><strong>ALTER</strong>-is used to alter the structure of the database.</li>
<li><strong>TRUNCATE</strong>–is used to remove all records from a table, including all spaces allocated for the records are removed.</li>
<li><strong>COMMENT</strong> –is used to add comments to the data dictionary.</li>
<li><strong>RENAME</strong> –is used to rename an object existing in the database.</li>
</ul>
</li>
<li><p>DML(Data Manipulation Language) : </p>
<p>The SQL commands that deals with the manipulation of data present in database belong to DML or Data Manipulation Language and this includes most of the SQL statements.</p>
<p><strong>Examples of DML:</strong></p>
<ul>
<li><strong>SELECT</strong> – is used to retrieve data from the a database.</li>
<li><strong>INSERT</strong> – is used to insert data into a table.</li>
<li><strong>UPDATE</strong> – is used to update existing data within a table.</li>
<li><strong>DELETE</strong> – is used to delete records from a database table.</li>
</ul>
</li>
<li><p>DCL(Data Control Language) : </p>
<p>DCL includes commands such as GRANT and REVOKE which mainly deals with the rights, permissions and other controls of the database system.</p>
<p><strong>Examples of DCL commands:</strong></p>
<ul>
<li><strong>GRANT</strong>-gives user’s access privileges to database.</li>
<li><strong>REVOKE</strong>-withdraw user’s access privileges given by using the GRANT command.</li>
</ul>
</li>
<li><p>TCL(transaction Control Language) : </p>
<p>TCL commands deals with the</p>
</li>
</ol>
<p>   transaction within the database</p>
<p>   .</p>
<p>   <strong>Examples of TCL commands:</strong></p>
<ul>
<li><strong>COMMIT</strong>– commits a Transaction.</li>
<li><strong>ROLLBACK</strong>– rollbacks a transaction in case of any error occurs.</li>
<li><strong>SAVEPOINT</strong>–sets a savepoint within a transaction.</li>
<li><strong>SET TRANSACTION</strong>–specify characteristics for the transaction.</li>
</ul>
<p><strong>DDL 主要是用来创建和修改database结构，例如表、字段、数据库的结构的修改等。</strong></p>
<h6 id="2-create-table-define"><a href="#2-create-table-define" class="headerlink" title="2 create table define"></a>2 create table define</h6><p>create table的经典格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@host<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use TUTORIALS;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE tutorials_tbl(</span><br><span class="line">-&gt; tutorial_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">-&gt; tutorial_title VARCHAR(100) NOT NULL,</span><br><span class="line">-&gt; tutorial_author VARCHAR(40) NOT NULL,</span><br><span class="line">-&gt; submission_date DATE,</span><br><span class="line">-&gt; PRIMARY KEY ( tutorial_id )</span><br><span class="line">-&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.16 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
<p>查看表的定义时，会发现实际有如下的字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tutorials_tbl`</span> (</span><br><span class="line">   <span class="string">`tutorial_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`tutorial_title`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`tutorial_author`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`submission_date`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`tutorial_id`</span>)</span><br><span class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>
<p>由此，可以看出：一个完整的数据库表的定义，应该包括：</p>
<p><strong>表名 、列定义 、 完整性约束 、引擎定义</strong></p>
<p>其中完整性约束与引擎定义在实际的字段中并非必要选项。</p>
<h6 id="3-完整性约束"><a href="#3-完整性约束" class="headerlink" title="3 完整性约束"></a>3 完整性约束</h6><p><strong>主键、外键、索引  （Key的特征）</strong><br><strong>默认、自增、非空   (Value 特征）</strong></p>
<p>PRIMARY KEY (PK)    标识该字段为该表的主键，可以唯一的标识记录<br>FOREIGN KEY (FK)    标识该字段为该表的外键<br>NOT NULL    标识该字段不能为空<br>UNIQUE KEY (UK)    标识该字段的值是唯一的<br>AUTO_INCREMENT    标识该字段的值自动增长（整数类型，而且为主键）<br>DEFAULT    为该字段设置默认值</p>
<p>UNSIGNED 无符号<br>ZEROFILL 使用0填充</p>
<p>在完整性约束中，存在一个核心的问题：</p>
<p><strong>Primary Key VS Unique Index？</strong></p>
<p>一个经典的回答如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Note that “primary” is called PRIMARY KEY not INDEX. </span><br><span class="line">    KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …) </span><br><span class="line">    INDEX is something on the physical level, helps improve access time <span class="keyword">for</span> table operations. </span><br><span class="line">    Behind every PK there is (usually) unique index created (automatically).</span><br></pre></td></tr></table></figure>
<p><strong>Key</strong> 是数据库理论中的概念，是<strong>逻辑设计</strong>层面的。</p>
<p><strong>Index</strong> 是实实在在的数据库对象，占用了存储空间，是<strong>物理实现</strong>层面的。</p>
<p>在多种场景下，二者的概念可以混用。</p>
<p><strong>各种不同的Key设计，需要Index来具体实现</strong>。</p>
<p>在StackOverFlow中有一个Issue专门描述二者的区别：</p>
<p><a href="https://stackoverflow.com/questions/487314/primary-key-or-unique-index" target="_blank" rel="noopener">https://stackoverflow.com/questions/487314/primary-key-or-unique-index</a></p>
<p>简而言之：</p>
<p>共同点：<strong>A primary Key implies a unique index.</strong> </p>
<p>不同点：</p>
<ul>
<li>A primary key also implies NOT NULL, but a unique index can be nullable.</li>
<li>There can be only one primary key, but there can be multiple unique indexes.</li>
<li>If there is no clustered index defined then the primary key will be the clustered index.</li>
</ul>
<p><strong>Primary Key 是 Unique Index 的特殊形式。</strong></p>
<h6 id="4-CHARSET-与-COLLATE"><a href="#4-CHARSET-与-COLLATE" class="headerlink" title="4 CHARSET 与 COLLATE"></a>4 CHARSET 与 COLLATE</h6><p>在定义引擎时，会有如下的字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>
<p>如果不指定，则会使用默认值。</p>
<p>CHARSET与COLLATE的关系：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A character set is a set of symbols and encodings. A collation is a set of rules for comparing characters in a character set. Let's make the distinction clear with an example of an imaginary character set.</span><br><span class="line"></span><br><span class="line">Suppose that we have an alphabet with four letters: A, B, a, b. We give each letter a number: A = 0, B = 1, a = 2, b = 3. The letter A is a symbol, the number 0 is the encoding for A, and the combination of all four letters and their encodings is a character set.</span><br><span class="line"></span><br><span class="line">Suppose that we want to compare two string values, A and B. The simplest way to do this is to look at the encodings: 0 for A and 1 for B. Because 0 is less than 1, we say A is less than B. What we've just done is apply a collation to our character set. The collation is a set of rules (only one rule in this case): “compare the encodings.” We call this simplest of all possible collations a binary collation.</span><br><span class="line"></span><br><span class="line">But what if we want to say that the lowercase and uppercase letters are equivalent? Then we would have at least two rules: (1) treat the lowercase letters a and b as equivalent to A and B; (2) then compare the encodings. We call this a case-insensitive collation. It is a little more complex than a binary collation.</span><br><span class="line"></span><br><span class="line">In real life, most character sets have many characters: not just A and B but whole alphabets, sometimes multiple alphabets or eastern writing systems with thousands of characters, along with many special symbols and punctuation marks. Also in real life, most collations have many rules, not just for whether to distinguish lettercase, but also for whether to distinguish accents (an “accent” is a mark attached to a character as in German Ö), and for multiple-character mappings (such as the rule that Ö = OE in one of the two German collations).</span><br></pre></td></tr></table></figure>
<p>通过上述的这段描述，可以看出：</p>
<p><strong>CHARSET 是定义字符的编码集合，COLLATE 是定义字符的比较规则。</strong></p>
<p><strong>COLLATE会影响到ORDER BY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响`DISTINCT、GROUP BY、HAVING语句的查询结果</strong>。</p>
<p>通常，每种CharSet都有其所支持的COLLATE，每种CHARSET都会指定默认的COLLATE。</p>
<p>例如<code>Latin1</code>编码的默认<code>COLLATE</code>为<code>latin1_swedish_ci</code>，<code>GBK</code>编码的默认<code>COLLATE</code>为<code>gbk_chinese_ci</code>，<code>utf8mb4</code>编码的默认值为<code>utf8mb4_general_ci</code></p>
<h6 id="5-Distinct-column1，column"><a href="#5-Distinct-column1，column" class="headerlink" title="5 Distinct column1，column"></a>5 Distinct column1，column</h6><p>distinct的作用是去重。当选择一列时，去重是很好理解的，将这一列中的重复元素进行去除。</p>
<p>那么当distinct后面接2个column甚至更多，将会如何进行去重呢？</p>
<p>答案：将(column1，column2 ) 看做是一个二元的向量，进行去重。例如：</p>
<p>原始的表的数据为：</p>
<p><img src="http://pogngdcwy.bkt.clouddn.com/1554606604710wf3ixrnc.png?imageslim" alt="paste image"></p>
<p>执行命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sname,grade  <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>
<p>得到的结果如下：</p>
<p><img src="http://pogngdcwy.bkt.clouddn.com/15546067047796uh8qmdg.png?imageslim" alt="paste image"></p>
<p><strong>sname</strong>出现了2次。</p>
<h6 id="6-Where-子句-Between、In"><a href="#6-Where-子句-Between、In" class="headerlink" title="6 Where 子句 Between、In"></a>6 Where 子句 Between、In</h6><p>Between子句的用法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure>
<p>value的值可以是text、date、number。</p>
<p>注意，对于date，可以直接进行比较，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> birth <span class="keyword">between</span></span><br><span class="line"><span class="string">'1988-09-10'</span> <span class="keyword">and</span> <span class="string">'1988-09-20'</span> ;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>IN operator allows you to easily test if the expression matches any value in the list of values. It is used to remove the need of multiple OR condition in SELECT, INSERT, UPDATE or DELETE. You can also use NOT IN to exclude the rows in your list.</p>
<p>IN以及NOT IN的作用相当于是<strong>黑名单</strong>与<strong>白名单</strong>。</p>
<p>示例的查询代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; SELECT column_name(s)</span><br><span class="line">&gt; &gt; FROM table_name</span><br><span class="line">&gt; &gt; WHERE column_name IN (list_of_values);</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>关于between与in的用法可以参考：<a href="https://www.geeksforgeeks.org/sql-between-in-operator/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/sql-between-in-operator/</a></p>
<h6 id="6-Order-by"><a href="#6-Order-by" class="headerlink" title="6 Order by"></a>6 Order by</h6><blockquote>
<p>The ORDER BY statement in sql is used to sort the fetched data in either ascending or descending according to one or more columns.</p>
</blockquote>
<ul>
<li>By default ORDER BY sorts the data in <strong>ascending order.</strong></li>
<li>We can use the keyword DESC to sort the data in descending order and the keyword ASC to sort in ascending order.</li>
</ul>
<blockquote>
<p><strong>order by</strong> 可以根据一行，也可以根据多行。</p>
<blockquote>
<p><strong>Sort according to multiple columns</strong>:</p>
</blockquote>
<p>To sort in ascending or descending order we can use the keywords ASC or DESC respectively. To sort according to multiple columns, separate the names of columns by (,) operator.</p>
<p>Syntax:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; &gt;SELECT * FROM table_name ORDER BY column1 ASC|DESC , column2 ASC|DESC</span><br><span class="line">&gt; &gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</blockquote>
<p>对于上面的子句，首先按照column1进行排序，对于column1中的相同部分再按照column2中的内容进行排序。</p>
<p>order by字段可以参考：<a href="https://www.geeksforgeeks.org/sql-order-by/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/sql-order-by/</a></p>
<h6 id="7-Select-TOP"><a href="#7-Select-TOP" class="headerlink" title="7 Select TOP"></a>7 Select TOP</h6><p>并非所有的数据库都支持Select top（MS_SQL支持），MySQL可以用limit来达到，Oracle使用 <strong>ROWNUM</strong> 虚拟列</p>
<p>特别说下Oracle，对于虚拟列，与order by结合在一起使用时，需要特别注意，有时可能得不到想要的结果。</p>
<p>对于Select Top N的操作，可以直接使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= N</span><br></pre></td></tr></table></figure>
<p>rownum从1开始。如果要查询第M行到N行的数据，需要使用子查询。</p>
<p>或者，当rownum与order by 混合使用时，如果直接使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">11</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name;</span><br></pre></td></tr></table></figure>
<p>可能每次都会生成不同的结果，正确的使用方法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">   (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id)</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>详细参考：<a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns009.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns009.htm</a></p>
<h6 id="8-LIKE-CLAUSE"><a href="#8-LIKE-CLAUSE" class="headerlink" title="8 LIKE CLAUSE"></a>8 LIKE CLAUSE</h6><p>like的使用语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> pattern;</span><br></pre></td></tr></table></figure>
<p>like的模式匹配中，通常可以有如下的2个符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The pattern can contain special pattern-matching characters:</span><br><span class="line"></span><br><span class="line">An underscore (_) <span class="keyword">in</span> the pattern matches exactly one character (as opposed to one byte <span class="keyword">in</span> a multibyte character <span class="built_in">set</span>) <span class="keyword">in</span> the value.</span><br><span class="line"></span><br><span class="line">A percent sign (%) <span class="keyword">in</span> the pattern can match zero or more characters (as opposed to bytes <span class="keyword">in</span> a multibyte character <span class="built_in">set</span>) <span class="keyword">in</span> the value. The pattern <span class="string">'%'</span> cannot match a null.</span><br></pre></td></tr></table></figure>
<p>关于Like的更多用法（<strong>设置转义字符</strong>等等），请参考官方的文档：</p>
<p><a href="https://docs.oracle.com/cd/B13789_01/server.101/b10759/conditions016.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/B13789_01/server.101/b10759/conditions016.htm</a></p>
<h6 id="9-别名-Alias"><a href="#9-别名-Alias" class="headerlink" title="9 别名 Alias"></a>9 别名 Alias</h6><p>对于MySQL来说，使用<strong>AS</strong>，来起到别名的作用。</p>
<p><strong>存在表别名与列的别名。</strong></p>
<p>在Oracle的帮助文档中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Oracle ALIASES can be used to create a temporary name <span class="keyword">for</span> columns or tables.</span><br><span class="line"></span><br><span class="line">COLUMN ALIASES are used to make column headings <span class="keyword">in</span> your result <span class="built_in">set</span> easier to <span class="built_in">read</span>.</span><br><span class="line">TABLE ALIASES are used to shorten your SQL to make it easier to <span class="built_in">read</span> or when you are performing a self join (ie: listing the same table more than once <span class="keyword">in</span> the FROM clause).</span><br></pre></td></tr></table></figure>
<p>列的别名使得查询结果更加易读。表的别名，可以使得SQL语句更加简短尤其是当实现Self Join。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">column_name AS alias_name</span><br><span class="line">table_name alias_name</span><br></pre></td></tr></table></figure>
<p>在Oracle中，实际在测试中发现，对于表，不能加as，对于列，可以加可不加。</p>
<p>需要注意的几个事项：</p>
<ul>
<li>If the <em>alias_name</em> contains spaces, you must enclose the <em>alias_name</em> in quotes.</li>
<li>It is acceptable to use spaces when you are aliasing a column name. However, it is not generally good practice to use spaces when you are aliasing a table name.</li>
<li>The <em>alias_name</em> is only valid within the scope of the SQL statement.</li>
</ul>
<p><strong>别名只在当前的SQL语句中有效。</strong></p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> contact_id, first_name || last_name <span class="keyword">AS</span> <span class="keyword">NAME</span></span><br><span class="line"><span class="keyword">FROM</span> contacts</span><br><span class="line"><span class="keyword">WHERE</span> last_name = <span class="string">'Anderson'</span>;</span><br></pre></td></tr></table></figure>
<p>表的别名在表Join时应用更加凸显：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.product_id, p.product_name, categories.category_name</span><br><span class="line"><span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> categories</span><br><span class="line"><span class="keyword">ON</span> p.category_id = categories.category_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> p.product_name <span class="keyword">ASC</span>, categories.category_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<p>参考如下的连接：<a href="https://www.techonthenet.com/oracle/alias.php" target="_blank" rel="noopener">https://www.techonthenet.com/oracle/alias.php</a></p>
<h6 id="10-JOIN联表查询"><a href="#10-JOIN联表查询" class="headerlink" title="10 JOIN联表查询"></a>10 JOIN联表查询</h6><p>There are 4 different types of Oracle joins:</p>
<ul>
<li><p>Oracle INNER JOIN (or sometimes called simple join)</p>
</li>
<li><p>Oracle LEFT OUTER JOIN (or sometimes called LEFT JOIN)</p>
</li>
<li><p>Oracle RIGHT OUTER JOIN (or sometimes called RIGHT JOIN)</p>
</li>
<li><p>Oracle FULL OUTER JOIN (or sometimes called FULL JOIN)</p>
</li>
</ul>
<p>Inner Join：根据联合条件，选择两表中的共有的value。</p>
<p>在实际操作时，需要注意排列组合的实现：表 <strong>hobby</strong>的数据如下：</p>
<p><img src="http://pogngdcwy.bkt.clouddn.com/1554625808204f6rtvm2c.png?imageslim" alt="paste image"></p>
<p>表 <strong>lessons</strong>的数据如下：</p>
<p><img src="http://pogngdcwy.bkt.clouddn.com/1554625884152e7t4rr7i.png?imageslim" alt="paste image"></p>
<p>执行的联表的语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> h.sname,h.hoby,l.lesson <span class="keyword">from</span> hobby h <span class="keyword">inner</span> <span class="keyword">join</span> lessons l <span class="keyword">on</span> h.sname = l.sname;</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<p><img src="http://pogngdcwy.bkt.clouddn.com/1554626227882wympqob5.png?imageslim" alt="paste image"></p>
<p><strong>由此可以推知：Inner Join会以内联字段作为桥梁，进行排列组合式的联结。</strong></p>
<p>Left Join：左联。<strong>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</strong></p>
<p>Right Join:  右联。<strong>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</strong></p>
<p><strong>左联与右联主要差别在于，以哪张表为基础，去另外一张表中寻找数据。注意，在寻找数据时，不是一一对应的关系，也可能出现排列组合的方式。</strong></p>
<p>FULL JOIN：全联结。相当于左联结与右联结的并集。</p>
<h6 id="11-Union-amp-amp-Union-ALL"><a href="#11-Union-amp-amp-Union-ALL" class="headerlink" title="11 Union &amp;&amp; Union ALL"></a>11 Union &amp;&amp; Union ALL</h6><p>Union用于将不同的查询结果进行合并：</p>
<p><strong>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</strong></p>
<p>Union 与 union all的区别在于，union相当于distinct，而union all是包含重复的项。</p>
<h6 id="12-Select-into"><a href="#12-Select-into" class="headerlink" title="12 Select into"></a>12 Select into</h6><p>Select into 语句从1个或者多个数据库表中获取数据，并且将select的值分配到变量或者集合。</p>
<p> <strong>In its default usage (<code>SELECT ... INTO</code>), this statement retrieves one or more columns from a single row</strong></p>
<p> <strong>In its bulk usage (<code>SELECT ... BULK COLLECT INTO</code>), this statement retrieves an entire result set at once.</strong></p>
<p>默认select into从单行中截取数据，可以截取多列，如果有多行的数据返回，则会报错：<strong>TOO_MANY_ROWS</strong>，例如下格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,sno <span class="keyword">into</span> l_name,l_cnt <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">9527</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> l_cnt，l_name <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line">TYPE stu_record IS RECORD(</span><br><span class="line">         SNO NUMBER,</span><br><span class="line">         Name VARCHAR2(32)</span><br><span class="line">         );</span><br><span class="line">rec1 stu_record;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> rec1 <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">9527</span>;</span><br></pre></td></tr></table></figure>
<p>使用select into时，需要注意异常的捕捉：</p>
<p>一个参考的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">declare </span><br><span class="line">  TYPE stu_record IS RECORD(</span><br><span class="line">         SNO NUMBER,</span><br><span class="line">         Name VARCHAR2(32)</span><br><span class="line">         );</span><br><span class="line">         </span><br><span class="line">  l_cnt number := 0;</span><br><span class="line">  l_name varchar2(32) := &apos;&apos;;</span><br><span class="line">  </span><br><span class="line">  rec1 stu_record;</span><br><span class="line"> </span><br><span class="line">begin</span><br><span class="line">  select * into rec1 from student where sno = 9910;</span><br><span class="line">  dbms_output.put_line(rec1.SNO || &apos; is the number of lines&apos; || rec1.Name);</span><br><span class="line">exception</span><br><span class="line">  when no_data_found or too_many_rows then</span><br><span class="line">    dbms_output.put_line(&apos;error found&apos;);</span><br><span class="line">  when others then</span><br><span class="line">    dbms_output.put_line(&apos;other error found&apos;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p><strong>If no rows are returned, PL/SQL raises <code>NO_DATA_FOUND</code>. You can guard against this exception by selecting the result of an aggregate function, such as <code>COUNT(*)</code> or <code>AVG()</code>, where practical.</strong> </p>
<p><strong>These functions are guaranteed to return a single value, even if no rows match the condition.</strong></p>
<p>对于 <code>SELECT ... BULK COLLECT INTO</code> ,返回的是多行数据吗，需要set up集合变量来存储结果，<strong>You can declare associative arrays or nested tables that grow as needed to hold the entire result set.</strong></p>
<h6 id="13-存储过程-调试方法"><a href="#13-存储过程-调试方法" class="headerlink" title="13 存储过程 调试方法"></a>13 存储过程 调试方法</h6><p>直接在SQL窗口中，是无法进行调试的，需要进入到“测试窗口”才可以进行，即使是存储过程和包，都是需要进入到测试窗口。</p>
<p>进入测试窗口的方法：“<strong>新建</strong>”–》“<strong>测试窗口</strong>”。调试时，可以看到调试输出信息。</p>
<p>如果提示：ORA-0131 :insufficient privileges DEBUG CONNECT SESSION</p>
<p>则表示当前的用户没有Debug权限，则需要使用系统用户进行授权，授权的脚本为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> DEBUG <span class="keyword">CONNECT</span> <span class="keyword">SESSION</span> <span class="keyword">to</span> scott</span><br></pre></td></tr></table></figure>
<h6 id="14-SQL-Subqueries-子查询"><a href="#14-SQL-Subqueries-子查询" class="headerlink" title="14  SQL Subqueries(子查询)"></a>14  SQL Subqueries(子查询)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In Oracle, a subquery is a query within a query. You can create subqueries within your SQL statements. These subqueries can reside in the WHERE clause, the FROM clause, or the SELECT clause.</span><br></pre></td></tr></table></figure>
<p>子查询即查询中的查询。可以驻留在<strong>where</strong>、<strong>from</strong>、<strong>select</strong>子句中。</p>
<p>在Where子句中，是最常见的场景 nested subqueries：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM all_tables tabs</span><br><span class="line">WHERE tabs.table_name IN (SELECT cols.table_name</span><br><span class="line">                          FROM all_tab_columns cols</span><br><span class="line">                          WHERE cols.column_name = &apos;SUPPLIER_ID&apos;);</span><br></pre></td></tr></table></figure>
<p>Oracle allows up to <strong>255</strong> levels of subqueries in the WHERE clause.</p>
<p>from子句中的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT suppliers.name, subquery1.total_amt</span><br><span class="line">FROM suppliers,</span><br><span class="line"> (SELECT supplier_id, SUM(orders.amount) AS total_amt</span><br><span class="line">  FROM orders</span><br><span class="line">  GROUP BY supplier_id) subquery1</span><br><span class="line">WHERE subquery1.supplier_id = suppliers.supplier_id;</span><br></pre></td></tr></table></figure>
<p>这又被叫做 inline views，与inner join异曲同工。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select student.sname,hobby.shobby from student,hobby where student.sno = hobby.sno</span><br><span class="line">select student.sname,hobby.shobby from student inner join hobby on  student.sno = hobby.sno;</span><br></pre></td></tr></table></figure>
<p>Select 子句场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT tbls.owner, tbls.table_name,</span><br><span class="line">  (SELECT COUNT(column_name) AS total_columns</span><br><span class="line">   FROM all_tab_columns cols</span><br><span class="line">   WHERE cols.owner = tbls.owner</span><br><span class="line">   AND cols.table_name = tbls.table_name) subquery2</span><br></pre></td></tr></table></figure>
<p>The subquery has been aliased with the name <em>subquery2</em>. This will be the name used to reference this subquery or any of its fields.</p>
<p><strong>The trick to placing a subquery in the select clause is that the subquery must return a single value</strong>. This is why an aggregate function such as <a href="https://www.techonthenet.com/oracle/functions/sum.php" target="_blank" rel="noopener">SUM function</a>, <a href="https://www.techonthenet.com/oracle/functions/count.php" target="_blank" rel="noopener">COUNT function</a>, <a href="https://www.techonthenet.com/oracle/functions/min.php" target="_blank" rel="noopener">MIN function</a>, or <a href="https://www.techonthenet.com/oracle/functions/max.php" target="_blank" rel="noopener">MAX function</a> is commonly used in the subquery.</p>
<p>如果要在select 子句中添加子句，要保证返回的值是一个单个的值。</p>
<h6 id="15-Collection-集合"><a href="#15-Collection-集合" class="headerlink" title="15  Collection 集合"></a>15  Collection 集合</h6><p>学习参考：<a href="https://www.tutorialspoint.com/plsql/plsql_collections.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/plsql/plsql_collections.htm</a></p>
<p><a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/05_colls.htm#20425" target="_blank" rel="noopener">https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/05_colls.htm#20425</a></p>
<p>PLSQL有3种类型的集合。</p>
<p>PL/SQL provides three collection types</p>
<ul>
<li><p>Index-by tables or Associative array</p>
</li>
<li><p>Nested table</p>
</li>
<li><p>Variable-size array or Varray</p>
</li>
</ul>
<h6 id="16-From-table-to-table"><a href="#16-From-table-to-table" class="headerlink" title="16 From table to table"></a>16 From table to table</h6><p>1）<strong>INSERT INTO SELECT</strong> </p>
<p>从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p>
<p>在插入时，要需要注意待插入表的约束的情况。示例的一个插入语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">select</span> * <span class="keyword">from</span> STUDENT_BAK b <span class="keyword">where</span> b.sno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> sno <span class="keyword">from</span> student)</span><br></pre></td></tr></table></figure>
<p>2) <strong>create  table as select</strong> </p>
<p>新建的表要求不存在，创建一个新表，从一个表中的数据复制另外一个表中的数据。<strong>但是这种方式只会保留数据，表的约束并不会同步过来。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table student_bak as select * from STUDENT t;</span><br></pre></td></tr></table></figure>
<h6 id="17-View视图"><a href="#17-View视图" class="headerlink" title="17 View视图"></a>17 View视图</h6><p>参考如下的连接：<a href="https://www.techonthenet.com/oracle/views.php" target="_blank" rel="noopener">https://www.techonthenet.com/oracle/views.php</a></p>
<p>View与Table的区别点摘抄如下：</p>
<p>区别：</p>
<p>​      1、视图是已经编译好的sql语句。而表不是<br>​      2、视图没有实际的物理记录。而表有。<br>​      3、表是内容，视图是窗口<br>​      4、表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改<br>​      5、表是内模式，视图是外模式<br>​      6、视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。<br>​      7、表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。 </p>
<p>​     8、视图的建立与删除只影响视图本身，不影响对应的基本表。</p>
<p>联系：<strong>视图（view）是在基本表之上建立的表</strong>，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。</p>
<p>​      一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p>
<p>在普通用户下创建view时，会提示权限不足，可以使用如下的指令在sysdba模式下授权：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">view</span> <span class="keyword">to</span> scott</span><br></pre></td></tr></table></figure>
<p><strong>View的创建</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">columns</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line">  [<span class="keyword">WHERE</span> conditions];</span><br></pre></td></tr></table></figure>
<p>​    where语句是可选的，其条件必须要被view_name中的视图所满足。</p>
<p><strong>View的更新</strong>：</p>
<p>可以在不drop view的前提下更新一个Oracle的View的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE or REPLACE VIEW sup_orders AS</span><br><span class="line">  SELECT suppliers.supplier_id, orders.quantity, orders.price</span><br><span class="line">  FROM suppliers</span><br><span class="line">  INNER JOIN orders</span><br><span class="line">  ON suppliers.supplier_id = orders.supplier_id</span><br><span class="line">  WHERE suppliers.supplier_name = &apos;Apple&apos;;</span><br></pre></td></tr></table></figure>
<p>这句话的命令是不存在则创建，存在则更新一个View。</p>
<p>如果直接更新一个view，可能会影响到实际的数据。</p>
<p><strong>Question:</strong> Can you update the data in an Oracle VIEW?</p>
<p><strong>Answer:</strong> A VIEW in Oracle is created by joining one or more tables. When you update record(s) in a VIEW, it updates the records in the underlying tables that make up the View.</p>
<p>So, yes, you can update the data in an Oracle VIEW providing you have the proper privileges to the underlying Oracle tables.</p>
<p><strong>View的删除</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW sup_orders;</span><br></pre></td></tr></table></figure>
<p>注意，删除了view，这个view所依赖的表不会有影响。<br>类似的，删除了表，这个view依旧会存在，只是在使用时会提示数据错误问题。</p>
<h6 id="18-函数"><a href="#18-函数" class="headerlink" title="18 函数"></a>18 函数</h6><p>Oracle标准的内建函数参见如下的列表：</p>
<p><a href="https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj55788.html" target="_blank" rel="noopener">https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj55788.html</a></p>
<p>聚合函数：Aggregates (set functions)：</p>
<p><a href="https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj33923.html" target="_blank" rel="noopener">https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj33923.html</a></p>
<h6 id="19-Group-by"><a href="#19-Group-by" class="headerlink" title="19 Group by"></a>19 Group by</h6><p>参考链接：<a href="https://www.techonthenet.com/oracle/group_by.php" target="_blank" rel="noopener">https://www.techonthenet.com/oracle/group_by.php</a></p>
<p><strong>The Oracle GROUP BY clause is used in a<a href="https://www.techonthenet.com/oracle/select.php" target="_blank" rel="noopener"> SELECT statement</a> to collect data across multiple records and group the results by one or more columns.</strong></p>
<p>group by经常与聚合函数一起使用。In this case, the aggregate function returns the summary information per group。在此情况下，聚合函数返回的是每个组的sum信息。</p>
<p>The <code>GROUP BY</code> clause must contain only aggregates or grouping columns.</p>
<p>group by只能包含聚合的列。</p>
<p>Group By有一个比较好的作用，在于去重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sno,sname from  stu_bak group by sno, sname</span><br></pre></td></tr></table></figure>
<p>通用的一个Group by的表达式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n, </span><br><span class="line">       aggregate_function (aggregate_expression)</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">GROUP BY expression1, expression2, ... expression_n;</span><br></pre></td></tr></table></figure>
<p>注意几个约束条件：</p>
<p>1）<strong>The expressions that are not encapsulated within an aggregate function and must be included in the GROUP BY clause</strong></p>
<p>未出现在聚合函数中的expression必须要包含在group by子句中。</p>
<p>2）<strong>aggregate_function</strong> It can be a function such as<a href="https://www.techonthenet.com/oracle/functions/sum.php" target="_blank" rel="noopener"> SUM</a>,<a href="https://www.techonthenet.com/oracle/functions/count.php" target="_blank" rel="noopener"> COUNT</a>,<a href="https://www.techonthenet.com/oracle/functions/min.php" target="_blank" rel="noopener"> MIN</a>,<a href="https://www.techonthenet.com/oracle/functions/max.php" target="_blank" rel="noopener"> MAX</a>, or <a href="https://www.techonthenet.com/oracle/functions/avg.php" target="_blank" rel="noopener">AVG</a> functions.</p>
<p>3）<strong>aggregate_expression</strong>：This is the column or expression that the <em>aggregate_function</em> will be used on.</p>
<p>4）<strong>tables</strong>：The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause.</p>
<p>5）<strong>WHERE conditions</strong>：Optional. The conditions that must be met for the records to be selected.</p>
<p>Group中<code>aggregate_function</code>可以认为是对<strong>group分组的操作</strong>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,count(*) from stu_bak group by sname;</span><br></pre></td></tr></table></figure>
<p>此处的count(<em>)并非是整个表的数量，上述的语句的含义为：按照sname进行分组，并对分组执行count(\</em>)，统计分组的数量。</p>
<h6 id="20-Having子句"><a href="#20-Having子句" class="headerlink" title="20 Having子句"></a>20 Having子句</h6><p>having子句需要与Group by一起使用，<strong>作用是对group的分组再次进行筛选</strong>。</p>
<p>只对聚合的结果进行筛选。</p>
<p>The Oracle HAVING clause is used in combination with the<a href="https://www.techonthenet.com/oracle/group_by.php" target="_blank" rel="noopener"> GROUP BY clause</a> to restrict the groups of returned rows to only those whose the condition is TRUE.</p>
<p>使用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n, </span><br><span class="line">       aggregate_function (aggregate_expression)</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">GROUP BY expression1, expression2, ... expression_n</span><br><span class="line">HAVING having_condition;</span><br></pre></td></tr></table></figure>
<p>在Group by的约束后，又增加了如下的一个：</p>
<p><strong>having_condition</strong>：This is a further condition applied only to the <strong>aggregated results</strong> to restrict the groups of returned rows. Only those groups whose condition evaluates to TRUE will be included in the result set.</p>
<p>是对聚合的结果的约束加强。示例的脚本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> partment,<span class="keyword">sum</span>(salary) <span class="keyword">from</span> EMPLOYEE t  <span class="keyword">group</span> <span class="keyword">by</span> partment <span class="keyword">having</span> <span class="keyword">sum</span>(sales)&gt;=<span class="number">30</span> ;</span><br></pre></td></tr></table></figure>
<h6 id="21-DUAL表"><a href="#21-DUAL表" class="headerlink" title="21 DUAL表"></a>21 DUAL表</h6><p>dual表是由Oracle数据库自动创建的一张表，本质上dual属于sys schema，但是其他的非SYS用户可以访问，其有其自身的列：<strong>DUMMY</strong>，且其值为：X，其类型为 <strong>VARCHAR2()</strong></p>
<p>常用在无特定表的Select查询。</p>
<blockquote>
<p>Selecting from the <code>DUAL</code> table is useful for computing a constant expression with the <code>SELECT</code> statement. </p>
</blockquote>
<p>在网上查询到，使用这个表可以如下的事情：</p>
<p>1）查询当前的用户：select user from dual</p>
<p>2）调用系统函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual   获得当前系统时间</span><br><span class="line">select SYS_CONTEXT(&apos;USERENV&apos;,&apos;TERMINAL&apos;) from dual   获得主机名</span><br><span class="line">select SYS_CONTEXT(&apos;USERENV&apos;,&apos;language&apos;) from dual  获得当前locale</span><br><span class="line">select dbms_random.random from dual     获得一个随机数</span><br><span class="line">select 3+5 as add_value,5+7 as sub_value from dual;    计算结果后，保存到不同的列值中</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><blockquote><p>原文作者: Clark Wu</p><p>原文链接: <a href="http://yoursite.com/2019/04/11/DML-DDL/">http://yoursite.com/2019/04/11/DML-DDL/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/04/12/PLSQL-Cursor使用方法研究/" class="pre">PLSQL Cursor使用方法研究</a><a href="/2019/03/25/TCP/" class="next">TCP、UDP、Port、Socket 温故知新</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MzIxNC8xOTc2MA=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL-DDL-amp-amp-DML-温故知新"><span class="toc-text">MySQL DDL&amp;&amp;DML 温故知新</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-DDL-in-SQL"><span class="toc-text">1 DDL in SQL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-create-table-define"><span class="toc-text">2 create table define</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-完整性约束"><span class="toc-text">3 完整性约束</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-CHARSET-与-COLLATE"><span class="toc-text">4 CHARSET 与 COLLATE</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-Distinct-column1，column"><span class="toc-text">5 Distinct column1，column</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-Where-子句-Between、In"><span class="toc-text">6 Where 子句 Between、In</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-Order-by"><span class="toc-text">6 Order by</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-Select-TOP"><span class="toc-text">7 Select TOP</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-LIKE-CLAUSE"><span class="toc-text">8 LIKE CLAUSE</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9-别名-Alias"><span class="toc-text">9 别名 Alias</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10-JOIN联表查询"><span class="toc-text">10 JOIN联表查询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#11-Union-amp-amp-Union-ALL"><span class="toc-text">11 Union &amp;&amp; Union ALL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#12-Select-into"><span class="toc-text">12 Select into</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#13-存储过程-调试方法"><span class="toc-text">13 存储过程 调试方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#14-SQL-Subqueries-子查询"><span class="toc-text">14  SQL Subqueries(子查询)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#15-Collection-集合"><span class="toc-text">15  Collection 集合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#16-From-table-to-table"><span class="toc-text">16 From table to table</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#17-View视图"><span class="toc-text">17 View视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#18-函数"><span class="toc-text">18 函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#19-Group-by"><span class="toc-text">19 Group by</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#20-Having子句"><span class="toc-text">20 Having子句</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#21-DUAL表"><span class="toc-text">21 DUAL表</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/PLSQL-包的使用/">PLSQL 包的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/12/PLSQL-Cursor使用方法研究/">PLSQL Cursor使用方法研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/DML-DDL/">MySQL/Oracle DDL&&DML 温故知新</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/25/TCP/">TCP、UDP、Port、Socket 温故知新</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/VSCode与Git联合使用方法/">VSCode与Git联合使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/20/Python-调试技巧/">Python 调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/Golang-json-mysql-Data-Transfer/">Golang json && mysql Data Transfer</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/16/hello-world/">Qiniu Image Upload</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/16/test-my-site/">Hexo搭建个人博客站点のSpecil Tips</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Clark Wu.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>