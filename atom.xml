<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在路上</title>
  
  <subtitle>修心养性，健体强身，终生学习！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-17T02:12:54.575Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Clark Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PLSQL 包的使用</title>
    <link href="http://yoursite.com/2019/04/17/PLSQL-%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/17/PLSQL-包的使用/</id>
    <published>2019-04-17T02:12:48.000Z</published>
    <updated>2019-04-17T02:12:54.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PLSQL-包的使用"><a href="#PLSQL-包的使用" class="headerlink" title="PLSQL 包的使用"></a>PLSQL 包的使用</h4><h5 id="1-包的介绍"><a href="#1-包的介绍" class="headerlink" title="1 包的介绍"></a>1 包的介绍</h5><p>package是PLSQL的<strong>五大</strong>程序元素的组合：<strong>变量</strong>、<strong>常量</strong>、<strong>游标</strong>、<strong>过程</strong>、<strong>函数</strong> 。</p><p>与面向对象语言的类比：</p><p>变量                =====  成员变量</p><p>过程&amp;&amp;函数    =====  类方法</p><p>与高级语言类似，包中的元素也分为公共元素和私有元素，区别在于作用域不一致。</p><blockquote><p>与C语言类似：PLSQL中变量在使用前一定要声明，有专门的<strong>declare</strong>区域声明变量。</p></blockquote><p>与C语言、Go语言等其他的语言类似，对于变量而言，其作用域主要有：</p><p>1）包的内部整体可见；</p><p>2）包内的过程或者函数内部；</p><p>3）包内外均可见。</p><p><strong>公用元素不仅可以被包中的函数、过程所调用，也可以被包外的PL/SQL程序访问，而私有元素只能被包内的函数和过程序所访问</strong>。</p><p>一个package由2个部分组成：<strong>包头（包说明） &amp;&amp; 包体（包主体）</strong></p><p>包说明（PACKAGE）：包说明部分声明包内数据类型、变量、常量、游标、子程序和异常错误处理等元素，这些元素为包的公有元素。<br>包主体（PACKAGE BODY）：包主体则是包定义部分的具体实现，它定义了包定义部分所声明的游标和子程序，在包主体中还可以声明包的私有元素。</p><p>使用时的注意事项：</p><ol><li>包体的编译要在包头编译之后；</li><li>在包体中实现的过程、函数、游标的名称必须与包说明中的过程、函数、游标一致，包括名称、参数的名称以及参数的模式（IN、OUT、IN OUT）。并建议按包说明中的次序定义包体中具体的实现。</li><li>在包体中声明的数据类型、变量、常量都是私有的，只能在包体中使用而不能被印刷体外的应用程序访问与使用。</li><li>在包体执行部分，可对包说明，包体中声明的公有或私有变量进行初始化或其它设置。</li></ol><p>理解第4条，是一个非常重要的点。</p><p>package的声明和定义的示例脚本如下：</p><p>包头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] PACKAGE package_name</span><br><span class="line">  [AUTHID &#123;CURRENT_USER | DEFINER&#125;]</span><br><span class="line">  &#123;IS | AS&#125;</span><br><span class="line">  [公有数据类型定义[公有数据类型定义]…]</span><br><span class="line">  [公有游标声明[公有游标声明]…]</span><br><span class="line">  [公有变量、常量声明[公有变量、常量声明]…]</span><br><span class="line">  [公有函数声明[公有函数声明]…]</span><br><span class="line">  [公有过程声明[公有过程声明]…]</span><br><span class="line">END [package_name];</span><br></pre></td></tr></table></figure><p>包体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] PACKAGE BODY package_name</span><br><span class="line">  &#123;IS | AS&#125;</span><br><span class="line">  [私有数据类型定义[私有数据类型定义]…]</span><br><span class="line">  [私有变量、常量声明[私有变量、常量声明]…]</span><br><span class="line">  [私有异常错误声明[私有异常错误声明]…]</span><br><span class="line">  [私有函数声明和定义[私有函数声明和定义]…]</span><br><span class="line">  [私有函过程声明和定义[私有函过程声明和定义]…]</span><br><span class="line">  [公有游标定义[公有游标定义]…]</span><br><span class="line">  [公有函数定义[公有函数定义]…]</span><br><span class="line">  [公有过程定义[公有过程定义]…]</span><br><span class="line">BEGIN</span><br><span class="line">  执行部分(初始化部分)</span><br><span class="line">END package_name;</span><br></pre></td></tr></table></figure><p>通过观察发现，在包体部分，有个<strong>BEGIN</strong>开始的执行部分，经过实际代码测试发现：</p><p><strong>这个执行体部分相当于是Go语言的init函数</strong></p><p>当外部PLSQL程序有用到此package中的元素（包括变量和方法）时，就会初始化这个包，即调用执行部分。</p><h5 id="2-包的使用"><a href="#2-包的使用" class="headerlink" title="2 包的使用"></a>2 包的使用</h5><p>本节将演示包与包的调用。</p><p>1）首先定义一个包：<strong>student_operate</strong></p><p>包的定义代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--包头</span><br><span class="line">create or replace package student_operate is</span><br><span class="line">g_name varchar2(32);</span><br><span class="line">Procedure CalcTotalNum(grade number,total out number);</span><br><span class="line"></span><br><span class="line">end student_operate;</span><br><span class="line"></span><br><span class="line">--包体</span><br><span class="line">create or replace package body student_operate is</span><br><span class="line"></span><br><span class="line">l_hobbycnt number; </span><br><span class="line"></span><br><span class="line">Procedure CalcTotalNum(grade number,total out number)</span><br><span class="line">as</span><br><span class="line">  l_count number;</span><br><span class="line">  l_grade number := grade;</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  select count(*) into l_count from student where grade = l_grade;</span><br><span class="line">  total := l_count;</span><br><span class="line">  dbms_output.put_line(&apos;CalcTotalNum:hello world&apos;);</span><br><span class="line">  l_hobbycnt := 10;</span><br><span class="line">  dbms_output.put_line(&apos;hobby cnt is set to 10&apos;); </span><br><span class="line">  </span><br><span class="line">exception</span><br><span class="line">  when others then</span><br><span class="line">    dbms_output.put_line(&apos;When Error in CalcTotalNum&apos;);</span><br><span class="line">  </span><br><span class="line">end CalcTotalNum;</span><br></pre></td></tr></table></figure><p>2）然后定义一个包：<strong>TEACHER_OPERATE</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--包头</span><br><span class="line">create or replace package TEACHER_OPERATE is</span><br><span class="line"></span><br><span class="line">Procedure PrintGlobleVar;</span><br><span class="line"></span><br><span class="line">end TEACHER_OPERATE;</span><br><span class="line"></span><br><span class="line">--包体</span><br><span class="line">create or replace package body TEACHER_OPERATE is</span><br><span class="line"></span><br><span class="line">Procedure PrintGlobleVar as</span><br><span class="line">begin</span><br><span class="line">  if student_operate.g_name is null then</span><br><span class="line">    dbms_output.put_line(&apos;null&apos; || &apos;Hello Kitty&apos;);</span><br><span class="line">  else </span><br><span class="line">    dbms_output.put_line(student_operate.g_name || &apos;Hello Kitty&apos;);</span><br><span class="line">  end if;</span><br><span class="line"> </span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">end TEACHER_OPERATE;</span><br></pre></td></tr></table></figure><h5 id="3-包的调试"><a href="#3-包的调试" class="headerlink" title="3 包的调试"></a>3 包的调试</h5><p>在第2部分定义了2个包，接下来使用PLSQL Developer工具来进行调试。</p><p>在<strong>PrintGlobleVar</strong>右击，选择“<strong>测试</strong>”，则工具自动打开“测试窗口”，并创建一段脚本来方便测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">  -- Call the procedure</span><br><span class="line">  teacher_operate.printgloblevar;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>然后按 <strong>F9</strong>，点击单步调试的按钮。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;PLSQL-包的使用&quot;&gt;&lt;a href=&quot;#PLSQL-包的使用&quot; class=&quot;headerlink&quot; title=&quot;PLSQL 包的使用&quot;&gt;&lt;/a&gt;PLSQL 包的使用&lt;/h4&gt;&lt;h5 id=&quot;1-包的介绍&quot;&gt;&lt;a href=&quot;#1-包的介绍&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PLSQL Cursor使用方法研究</title>
    <link href="http://yoursite.com/2019/04/12/PLSQL-Cursor%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2019/04/12/PLSQL-Cursor使用方法研究/</id>
    <published>2019-04-12T09:40:56.000Z</published>
    <updated>2019-04-12T09:40:56.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PLSQL-Cursor使用方法研究"><a href="#PLSQL-Cursor使用方法研究" class="headerlink" title="PLSQL Cursor使用方法研究"></a>PLSQL Cursor使用方法研究</h4><h5 id="1-Cursor的基本操作"><a href="#1-Cursor的基本操作" class="headerlink" title="1 Cursor的基本操作"></a>1 Cursor的基本操作</h5><h6 id="1-Cursor-Declare"><a href="#1-Cursor-Declare" class="headerlink" title="1) Cursor Declare"></a>1) Cursor Declare</h6><blockquote><blockquote><p>A cursor is a SELECT statement that is defined within the <em>declaration</em> section of your PLSQL code. We’ll take a look at three different syntaxes to declare a cursor.</p><p>游标是在PLSQL的声明部分定义的，表示一个Select Statement</p><p>最简单的不带参数的Cursor定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; CURSOR cursor_name</span><br><span class="line">&gt; &gt; IS</span><br><span class="line">&gt; &gt;   SELECT_statement;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>同时，也存在带参数的Cursor，<strong>游标的参数只能是入参</strong>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; CURSOR c2 (subject_id_in IN varchar2)</span><br><span class="line">&gt; &gt; IS</span><br><span class="line">&gt; &gt;   SELECT course_number</span><br><span class="line">&gt; &gt;   FROM courses_tbl</span><br><span class="line">&gt; &gt;   WHERE subject_id = subject_id_in;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p>同时，Cursor还可以指定返回类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CURSOR c3</span><br><span class="line">RETURN courses_tbl%ROWTYPE</span><br><span class="line">IS</span><br><span class="line">   SELECT *</span><br><span class="line">   FROM courses_tbl</span><br><span class="line">   WHERE subject = &apos;Mathematics&apos;;</span><br></pre></td></tr></table></figure><h6 id="2-Open-Cursor"><a href="#2-Open-Cursor" class="headerlink" title="2) Open Cursor"></a>2) Open Cursor</h6><p>Once you’ve <a href="https://www.techonthenet.com/oracle/cursors/declare.php" target="_blank" rel="noopener">declared your cursor</a>, the next step is to use the OPEN statement to open the cursor.</p><p>当声明cursor后，下一步就是使用open语句打开。</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE Function FindCourse</span><br><span class="line">  ( name_in IN varchar2 )</span><br><span class="line">  RETURN number</span><br><span class="line">IS</span><br><span class="line">   cnumber number;</span><br><span class="line"></span><br><span class="line">   CURSOR c1</span><br><span class="line">   IS</span><br><span class="line">     SELECT course_number</span><br><span class="line">     FROM courses_tbl</span><br><span class="line">     WHERE course_name = name_in;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">   OPEN c1;</span><br><span class="line">   FETCH c1 INTO cnumber;</span><br><span class="line"></span><br><span class="line">   if c1%notfound then</span><br><span class="line">      cnumber := 9999;</span><br><span class="line">   end if;</span><br><span class="line"></span><br><span class="line">   CLOSE c1;</span><br><span class="line"></span><br><span class="line">RETURN cnumber;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>注意：打开游标的目的是执行Select语句：</p><p>就是执行游标所对应的SELECT 语句，将其查询结果放入工作区，并且指针指向工作区的首部，标识游标结果集合。</p><p>如果游标查询语句中带有FOR UPDATE选项，OPEN 语句还将锁定数据库表中游标结果集合对应的数据行。</p><h6 id="3-Fetch-Cursor"><a href="#3-Fetch-Cursor" class="headerlink" title="3) Fetch Cursor"></a>3) Fetch Cursor</h6><p>The purpose of using a cursor, in most cases, is to retrieve the rows from your cursor so that some type of operation can be performed on the data. After <a href="https://www.techonthenet.com/oracle/cursors/declare.php" target="_blank" rel="noopener">declaring</a> and <a href="https://www.techonthenet.com/oracle/cursors/open.php" target="_blank" rel="noopener">opening</a> your cursor, the next step is to use the FETCH statement to fetch rows from your cursor.</p><p>使用游标的目的，在大多数的情况下，是提取游标中的row数据，来使得一些操作类型能够在数据上执行。在声明、打开游标之后，下一步是fetch数据。</p><p>fetch数据是指检索集合中的数据行，放入指定的输出变量中。</p><p>在执行<strong>fetch</strong>语句时，需要注意：</p><blockquote><p><strong>执行FETCH语句时，每次返回一个数据行，然后自动将游标移动指向下一个数据行。当检索到最后一行数据时，如果再次执行FETCH语句，将操作失败，并将游标属性%NOTFOUND置为TRUE。所以每次执行完FETCH语句后，检查游标属性%NOTFOUND就可以判断FETCH语句是否执行成功并返回一个数据行，以便确定是否给对应的变量赋了值。</strong></p></blockquote><h6 id="4-Close-Cursor"><a href="#4-Close-Cursor" class="headerlink" title="4) Close Cursor"></a>4) Close Cursor</h6><p>The final step of working with cursors is to close the cursor once you have finished using it.</p><p>完成Cursor的使用后，最后一步是<strong>close</strong>游标。</p><h5 id="2-Cursor-的使用技巧"><a href="#2-Cursor-的使用技巧" class="headerlink" title="2 Cursor 的使用技巧"></a>2 Cursor 的使用技巧</h5><p>游标，提供了一种对具有多行数据查询结果集中的每一行数据分别进行单独处理的方法，是设计嵌入式SQL语句的应用程序的常用编程方式。</p><table><thead><tr><th>SQL语句</th><th>游标</th></tr></thead><tbody><tr><td>非查询语句</td><td>隐式的</td></tr><tr><td>结果是单行的查询语句</td><td>隐式的或显示的</td></tr><tr><td>结果是多行的查询语句</td><td>显示的</td></tr></tbody></table><p><strong>从上表看出，显式的游标只在查询语句中出现。</strong></p><p>在前小节中出现的4个步骤，都是指显式游标的处理过程，与前一小节的Select Statement对应起来了。</p><h6 id="1-cursor不带参数的遍历方法"><a href="#1-cursor不带参数的遍历方法" class="headerlink" title="1) cursor不带参数的遍历方法"></a>1) cursor不带参数的遍历方法</h6><p>cursor存在几个重要的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cursor_name%FOUND     布尔型属性，当最近一次提取游标操作FETCH成功则为 TRUE,否则为FALSE；</span><br><span class="line"></span><br><span class="line">Cursor_name%NOTFOUND   布尔型属性，与%FOUND相反；</span><br><span class="line"></span><br><span class="line">Cursor_name%ISOPEN     布尔型属性，当游标已打开时返回 TRUE；</span><br><span class="line"></span><br><span class="line">Cursor_name%ROWCOUNT   数字型属性，返回已从游标中读取的记录数。</span><br><span class="line"></span><br><span class="line">Cursor_name%ROWTYPE   游标记录类型</span><br></pre></td></tr></table></figure><p>因此，可以使用<strong>FOUND</strong>标记来遍历多行的数据，示例的PLSQL的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- Created on 2019/4/12 by CLARK </span><br><span class="line">declare </span><br><span class="line">  cursor c_cursor is select eno || salary,sales from employee;</span><br><span class="line">  v_ename employee.Partment%type;</span><br><span class="line">  v_sales employee.Sales%type;</span><br><span class="line">begin</span><br><span class="line">  open c_cursor;</span><br><span class="line">  fetch c_cursor into v_ename,v_sales;</span><br><span class="line">  while c_cursor%FOUND loop</span><br><span class="line">    dbms_Output.put_line(c_cursor%ROWCOUNT);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(v_ename||&apos;---&apos;||to_char(v_sales) );</span><br><span class="line">    fetch c_cursor into v_ename,v_sales;</span><br><span class="line">  end loop;</span><br><span class="line">  if c_cursor%ISOPEN then</span><br><span class="line">     dbms_Output.put_line(&apos;true&apos;);</span><br><span class="line">  else</span><br><span class="line">     dbms_Output.put_line(&apos;false&apos;);</span><br><span class="line">  end if;</span><br><span class="line">  close c_cursor;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h6 id="2-cursor带参数的遍历方法"><a href="#2-cursor带参数的遍历方法" class="headerlink" title="2) cursor带参数的遍历方法"></a>2) cursor带参数的遍历方法</h6><p>cursor 带参数时，参数将作用于Select Statement，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">  cursor cur(start_salary in number) is select eno,salary from employee where salary &gt; start_salary;</span><br><span class="line">  v_eno number;</span><br><span class="line">  v_salary number;</span><br><span class="line">begin</span><br><span class="line">  open cur(400);</span><br><span class="line">  loop</span><br><span class="line">    fetch cur into v_eno,v_salary;</span><br><span class="line">    exit when cur%NOTFOUND;</span><br><span class="line">    update employee set salary = salary - 11 where eno = v_eno;</span><br><span class="line">    commit;    </span><br><span class="line">  end loop;</span><br><span class="line">  </span><br><span class="line">exception</span><br><span class="line">  when others then</span><br><span class="line">    dbms_output.put_line(&apos;exception&apos;);</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p><strong>可以使用游标来定义变量，比声明Record的方式要安全和方便，不易出错</strong>：通过使用Cursor的属性：<strong>ROWTYPE</strong>。</p><p>如下的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">  cursor cur(start_salary in number) is select eno,salary from employee where salary &gt; start_salary;</span><br><span class="line">  e_record cur%ROWTYPE;</span><br><span class="line">begin</span><br><span class="line">  open cur(400);</span><br><span class="line">  loop</span><br><span class="line">    fetch cur into e_record;</span><br><span class="line">    exit when cur%NOTFOUND;</span><br><span class="line">    update employee set salary = e_record.salary - 11 where eno = e_record.eno;</span><br><span class="line">    commit;    </span><br><span class="line">  end loop;</span><br><span class="line">  </span><br><span class="line">exception</span><br><span class="line">  when others then</span><br><span class="line">    dbms_output.put_line(&apos;exception&apos;);</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h6 id="3-cursor-带参数且有返回值的用法"><a href="#3-cursor-带参数且有返回值的用法" class="headerlink" title="3) cursor 带参数且有返回值的用法"></a>3) cursor 带参数且有返回值的用法</h6><p>注意：尚未明确返回值的使用方法，本例的参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">   TYPE emp_record_type IS RECORD(</span><br><span class="line">        f_name   employees.first_name%TYPE,</span><br><span class="line">        h_date   employees.hire_date%TYPE);</span><br><span class="line">   v_emp_record EMP_RECORD_TYPE;</span><br><span class="line"></span><br><span class="line">   CURSOR c3(dept_id NUMBER, j_id VARCHAR2) --声明游标,有参数有返回值</span><br><span class="line">          RETURN EMP_RECORD_TYPE</span><br><span class="line">   IS</span><br><span class="line">      SELECT first_name, hire_date FROM employees</span><br><span class="line">      WHERE department_id = dept_id AND job_id = j_id;</span><br><span class="line">BEGIN</span><br><span class="line">   OPEN c3(j_id =&gt; &apos;AD_VP&apos;, dept_id =&gt; 90);  --打开游标,传递参数值</span><br><span class="line">   LOOP</span><br><span class="line">      FETCH c3 INTO v_emp_record;    --提取游标</span><br><span class="line">      IF c3%FOUND THEN</span><br><span class="line">         DBMS_OUTPUT.PUT_LINE(v_emp_record.f_name||&apos;的雇佣日期是&apos;</span><br><span class="line">                            ||v_emp_record.h_date);</span><br><span class="line">      ELSE</span><br><span class="line">         DBMS_OUTPUT.PUT_LINE(&apos;已经处理完结果集了&apos;);</span><br><span class="line">         EXIT;</span><br><span class="line">      END IF;</span><br><span class="line">   END LOOP;</span><br><span class="line">   CLOSE c3;   --关闭游标</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h5 id="3-Cursor-For-循环"><a href="#3-Cursor-For-循环" class="headerlink" title="3 Cursor For 循环"></a>3 Cursor For 循环</h5><h6 id="1）标准的针对游标For循环"><a href="#1）标准的针对游标For循环" class="headerlink" title="1）标准的针对游标For循环"></a>1）标准的针对游标For循环</h6><p>PLSQL提供了<strong>游标For循环</strong>语句，自动执行Open，Fetch，Close操作。</p><p>当进入循环时，游标FOR循环语句自动打开游标，并提取第一行游标数据，当程序处理完当前所提取的数据而进入下一次循环时，<br>游标FOR循环语句自动提取下一行数据供程序处理，当提取完结果集合中的所有数据行后结束循环，并自动关闭游标。</p><p>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR index_variable IN cursor_name[(value[, value]…)] LOOP</span><br><span class="line">    -- 游标数据处理代码</span><br><span class="line">  END LOOP;</span><br></pre></td></tr></table></figure><p>index_variable 为游标FOR循环语句隐含声明的索引变量，可以认为是<strong>记录变量</strong>，<strong>其结构与游标查询语句返回的结构集合的结构相同</strong>。</p><p>可以通过<strong>index_variable</strong>来提取游标数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">  cursor cur(start_salary in number) is select eno,salary from employee where salary &gt; start_salary;</span><br><span class="line">  e_record cur%ROWTYPE;</span><br><span class="line">begin</span><br><span class="line">  for index_record in cur(200) Loop</span><br><span class="line">     update employee set salary = index_record.salary - 11 where eno = index_record.eno;</span><br><span class="line">     commit;</span><br><span class="line">  end loop;</span><br><span class="line">  </span><br><span class="line">exception</span><br><span class="line">  when others then</span><br><span class="line">    dbms_output.put_line(&apos;exception&apos;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>注意：如果在游标查询语句的选择列表中存在计算列，则必须要为其指定别名后才能通过游标FOR循环语句的索引访问。</p><p>例如在下面的例子中，需要进行统计行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">  cursor cur is select count(1) as cnt from employee where salary &gt; 300;</span><br><span class="line">begin</span><br><span class="line">  for index_record in cur Loop</span><br><span class="line">     dbms_output.put_line(index_record.cnt);</span><br><span class="line">  end loop;</span><br><span class="line"></span><br><span class="line">exception</span><br><span class="line">  when others then</span><br><span class="line">    dbms_output.put_line(&apos;exception&apos;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>在游标的定义语句中，使用<code>select count(1) as cnt</code>来重命名，目的是为了在下面引用时可以访问到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2）子查询使用在游标For循环"><a href="#2）子查询使用在游标For循环" class="headerlink" title="2）子查询使用在游标For循环"></a>2）子查询使用在游标For循环</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    FOR c1_rec IN(SELECT department_name, location_id FROM departments) LOOP        </span><br><span class="line">DBMS_OUTPUT.PUT_LINE(c1_rec.department_name||&apos;---&apos;||c1_rec.location_id);</span><br><span class="line">    END LOOP;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;PLSQL-Cursor使用方法研究&quot;&gt;&lt;a href=&quot;#PLSQL-Cursor使用方法研究&quot; class=&quot;headerlink&quot; title=&quot;PLSQL Cursor使用方法研究&quot;&gt;&lt;/a&gt;PLSQL Cursor使用方法研究&lt;/h4&gt;&lt;h5 id=&quot;1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL/Oracle DDL&amp;&amp;DML 温故知新</title>
    <link href="http://yoursite.com/2019/04/11/DML-DDL/"/>
    <id>http://yoursite.com/2019/04/11/DML-DDL/</id>
    <published>2019-04-11T06:21:26.000Z</published>
    <updated>2019-04-17T11:48:21.130Z</updated>
    
    <content type="html"><![CDATA[<h5 id="MySQL-DDL-amp-amp-DML-温故知新"><a href="#MySQL-DDL-amp-amp-DML-温故知新" class="headerlink" title="MySQL DDL&amp;&amp;DML 温故知新"></a>MySQL DDL&amp;&amp;DML 温故知新</h5><h6 id="1-DDL-in-SQL"><a href="#1-DDL-in-SQL" class="headerlink" title="1 DDL in SQL"></a>1 DDL in SQL</h6><p>数据库定义语言。SQL的命令可以划分为四大类型：</p><ol><li><p>DDL(Data Definition Language) : </p><p>DDL or Data Definition Language actually consists of the SQL commands that can be used to define the database schema. It simply deals with descriptions of the database schema and is used to create and modify the structure of database objects in database.</p><p><strong>Examples of DDL commands:</strong></p><ul><li><strong>CREATE</strong> – is used to create the database or its objects (like table, index, function, views, store procedure and triggers).</li><li><strong>DROP</strong> – is used to delete objects from the database.</li><li><strong>ALTER</strong>-is used to alter the structure of the database.</li><li><strong>TRUNCATE</strong>–is used to remove all records from a table, including all spaces allocated for the records are removed.</li><li><strong>COMMENT</strong> –is used to add comments to the data dictionary.</li><li><strong>RENAME</strong> –is used to rename an object existing in the database.</li></ul></li><li><p>DML(Data Manipulation Language) : </p><p>The SQL commands that deals with the manipulation of data present in database belong to DML or Data Manipulation Language and this includes most of the SQL statements.</p><p><strong>Examples of DML:</strong></p><ul><li><strong>SELECT</strong> – is used to retrieve data from the a database.</li><li><strong>INSERT</strong> – is used to insert data into a table.</li><li><strong>UPDATE</strong> – is used to update existing data within a table.</li><li><strong>DELETE</strong> – is used to delete records from a database table.</li></ul></li><li><p>DCL(Data Control Language) : </p><p>DCL includes commands such as GRANT and REVOKE which mainly deals with the rights, permissions and other controls of the database system.</p><p><strong>Examples of DCL commands:</strong></p><ul><li><strong>GRANT</strong>-gives user’s access privileges to database.</li><li><strong>REVOKE</strong>-withdraw user’s access privileges given by using the GRANT command.</li></ul></li><li><p>TCL(transaction Control Language) : </p><p>TCL commands deals with the</p></li></ol><p>   transaction within the database</p><p>   .</p><p>   <strong>Examples of TCL commands:</strong></p><ul><li><strong>COMMIT</strong>– commits a Transaction.</li><li><strong>ROLLBACK</strong>– rollbacks a transaction in case of any error occurs.</li><li><strong>SAVEPOINT</strong>–sets a savepoint within a transaction.</li><li><strong>SET TRANSACTION</strong>–specify characteristics for the transaction.</li></ul><p><strong>DDL 主要是用来创建和修改database结构，例如表、字段、数据库的结构的修改等。</strong></p><h6 id="2-create-table-define"><a href="#2-create-table-define" class="headerlink" title="2 create table define"></a>2 create table define</h6><p>create table的经典格式为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@host<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use TUTORIALS;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE tutorials_tbl(</span><br><span class="line">-&gt; tutorial_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">-&gt; tutorial_title VARCHAR(100) NOT NULL,</span><br><span class="line">-&gt; tutorial_author VARCHAR(40) NOT NULL,</span><br><span class="line">-&gt; submission_date DATE,</span><br><span class="line">-&gt; PRIMARY KEY ( tutorial_id )</span><br><span class="line">-&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.16 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>查看表的定义时，会发现实际有如下的字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tutorials_tbl`</span> (</span><br><span class="line">   <span class="string">`tutorial_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`tutorial_title`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`tutorial_author`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`submission_date`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`tutorial_id`</span>)</span><br><span class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure><p>由此，可以看出：一个完整的数据库表的定义，应该包括：</p><p><strong>表名 、列定义 、 完整性约束 、引擎定义</strong></p><p>其中完整性约束与引擎定义在实际的字段中并非必要选项。</p><h6 id="3-完整性约束"><a href="#3-完整性约束" class="headerlink" title="3 完整性约束"></a>3 完整性约束</h6><p><strong>主键、外键、索引  （Key的特征）</strong><br><strong>默认、自增、非空   (Value 特征）</strong></p><p>PRIMARY KEY (PK)    标识该字段为该表的主键，可以唯一的标识记录<br>FOREIGN KEY (FK)    标识该字段为该表的外键<br>NOT NULL    标识该字段不能为空<br>UNIQUE KEY (UK)    标识该字段的值是唯一的<br>AUTO_INCREMENT    标识该字段的值自动增长（整数类型，而且为主键）<br>DEFAULT    为该字段设置默认值</p><p>UNSIGNED 无符号<br>ZEROFILL 使用0填充</p><p>在完整性约束中，存在一个核心的问题：</p><p><strong>Primary Key VS Unique Index？</strong></p><p>一个经典的回答如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Note that “primary” is called PRIMARY KEY not INDEX. </span><br><span class="line">    KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …) </span><br><span class="line">    INDEX is something on the physical level, helps improve access time <span class="keyword">for</span> table operations. </span><br><span class="line">    Behind every PK there is (usually) unique index created (automatically).</span><br></pre></td></tr></table></figure><p><strong>Key</strong> 是数据库理论中的概念，是<strong>逻辑设计</strong>层面的。</p><p><strong>Index</strong> 是实实在在的数据库对象，占用了存储空间，是<strong>物理实现</strong>层面的。</p><p>在多种场景下，二者的概念可以混用。</p><p><strong>各种不同的Key设计，需要Index来具体实现</strong>。</p><p>在StackOverFlow中有一个Issue专门描述二者的区别：</p><p><a href="https://stackoverflow.com/questions/487314/primary-key-or-unique-index" target="_blank" rel="noopener">https://stackoverflow.com/questions/487314/primary-key-or-unique-index</a></p><p>简而言之：</p><p>共同点：<strong>A primary Key implies a unique index.</strong> </p><p>不同点：</p><ul><li>A primary key also implies NOT NULL, but a unique index can be nullable.</li><li>There can be only one primary key, but there can be multiple unique indexes.</li><li>If there is no clustered index defined then the primary key will be the clustered index.</li></ul><p><strong>Primary Key 是 Unique Index 的特殊形式。</strong></p><h6 id="4-CHARSET-与-COLLATE"><a href="#4-CHARSET-与-COLLATE" class="headerlink" title="4 CHARSET 与 COLLATE"></a>4 CHARSET 与 COLLATE</h6><p>在定义引擎时，会有如下的字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure><p>如果不指定，则会使用默认值。</p><p>CHARSET与COLLATE的关系：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A character set is a set of symbols and encodings. A collation is a set of rules for comparing characters in a character set. Let's make the distinction clear with an example of an imaginary character set.</span><br><span class="line"></span><br><span class="line">Suppose that we have an alphabet with four letters: A, B, a, b. We give each letter a number: A = 0, B = 1, a = 2, b = 3. The letter A is a symbol, the number 0 is the encoding for A, and the combination of all four letters and their encodings is a character set.</span><br><span class="line"></span><br><span class="line">Suppose that we want to compare two string values, A and B. The simplest way to do this is to look at the encodings: 0 for A and 1 for B. Because 0 is less than 1, we say A is less than B. What we've just done is apply a collation to our character set. The collation is a set of rules (only one rule in this case): “compare the encodings.” We call this simplest of all possible collations a binary collation.</span><br><span class="line"></span><br><span class="line">But what if we want to say that the lowercase and uppercase letters are equivalent? Then we would have at least two rules: (1) treat the lowercase letters a and b as equivalent to A and B; (2) then compare the encodings. We call this a case-insensitive collation. It is a little more complex than a binary collation.</span><br><span class="line"></span><br><span class="line">In real life, most character sets have many characters: not just A and B but whole alphabets, sometimes multiple alphabets or eastern writing systems with thousands of characters, along with many special symbols and punctuation marks. Also in real life, most collations have many rules, not just for whether to distinguish lettercase, but also for whether to distinguish accents (an “accent” is a mark attached to a character as in German Ö), and for multiple-character mappings (such as the rule that Ö = OE in one of the two German collations).</span><br></pre></td></tr></table></figure><p>通过上述的这段描述，可以看出：</p><p><strong>CHARSET 是定义字符的编码集合，COLLATE 是定义字符的比较规则。</strong></p><p><strong>COLLATE会影响到ORDER BY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响`DISTINCT、GROUP BY、HAVING语句的查询结果</strong>。</p><p>通常，每种CharSet都有其所支持的COLLATE，每种CHARSET都会指定默认的COLLATE。</p><p>例如<code>Latin1</code>编码的默认<code>COLLATE</code>为<code>latin1_swedish_ci</code>，<code>GBK</code>编码的默认<code>COLLATE</code>为<code>gbk_chinese_ci</code>，<code>utf8mb4</code>编码的默认值为<code>utf8mb4_general_ci</code></p><h6 id="5-Distinct-column1，column"><a href="#5-Distinct-column1，column" class="headerlink" title="5 Distinct column1，column"></a>5 Distinct column1，column</h6><p>distinct的作用是去重。当选择一列时，去重是很好理解的，将这一列中的重复元素进行去除。</p><p>那么当distinct后面接2个column甚至更多，将会如何进行去重呢？</p><p>答案：将(column1，column2 ) 看做是一个二元的向量，进行去重。例如：</p><p>原始的表的数据为：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1554606604710wf3ixrnc.png?imageslim" alt="paste image"></p><p>执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sname,grade  <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>得到的结果如下：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/15546067047796uh8qmdg.png?imageslim" alt="paste image"></p><p><strong>sname</strong>出现了2次。</p><h6 id="6-Where-子句-Between、In"><a href="#6-Where-子句-Between、In" class="headerlink" title="6 Where 子句 Between、In"></a>6 Where 子句 Between、In</h6><p>Between子句的用法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure><p>value的值可以是text、date、number。</p><p>注意，对于date，可以直接进行比较，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> birth <span class="keyword">between</span></span><br><span class="line"><span class="string">'1988-09-10'</span> <span class="keyword">and</span> <span class="string">'1988-09-20'</span> ;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>IN operator allows you to easily test if the expression matches any value in the list of values. It is used to remove the need of multiple OR condition in SELECT, INSERT, UPDATE or DELETE. You can also use NOT IN to exclude the rows in your list.</p><p>IN以及NOT IN的作用相当于是<strong>黑名单</strong>与<strong>白名单</strong>。</p><p>示例的查询代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; SELECT column_name(s)</span><br><span class="line">&gt; &gt; FROM table_name</span><br><span class="line">&gt; &gt; WHERE column_name IN (list_of_values);</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>关于between与in的用法可以参考：<a href="https://www.geeksforgeeks.org/sql-between-in-operator/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/sql-between-in-operator/</a></p><h6 id="6-Order-by"><a href="#6-Order-by" class="headerlink" title="6 Order by"></a>6 Order by</h6><blockquote><p>The ORDER BY statement in sql is used to sort the fetched data in either ascending or descending according to one or more columns.</p></blockquote><ul><li>By default ORDER BY sorts the data in <strong>ascending order.</strong></li><li>We can use the keyword DESC to sort the data in descending order and the keyword ASC to sort in ascending order.</li></ul><blockquote><p><strong>order by</strong> 可以根据一行，也可以根据多行。</p><blockquote><p><strong>Sort according to multiple columns</strong>:</p></blockquote><p>To sort in ascending or descending order we can use the keywords ASC or DESC respectively. To sort according to multiple columns, separate the names of columns by (,) operator.</p><p>Syntax:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; &gt;SELECT * FROM table_name ORDER BY column1 ASC|DESC , column2 ASC|DESC</span><br><span class="line">&gt; &gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote><p>对于上面的子句，首先按照column1进行排序，对于column1中的相同部分再按照column2中的内容进行排序。</p><p>order by字段可以参考：<a href="https://www.geeksforgeeks.org/sql-order-by/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/sql-order-by/</a></p><h6 id="7-Select-TOP"><a href="#7-Select-TOP" class="headerlink" title="7 Select TOP"></a>7 Select TOP</h6><p>并非所有的数据库都支持Select top（MS_SQL支持），MySQL可以用limit来达到，Oracle使用 <strong>ROWNUM</strong> 虚拟列</p><p>特别说下Oracle，对于虚拟列，与order by结合在一起使用时，需要特别注意，有时可能得不到想要的结果。</p><p>对于Select Top N的操作，可以直接使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= N</span><br></pre></td></tr></table></figure><p>rownum从1开始。如果要查询第M行到N行的数据，需要使用子查询。</p><p>或者，当rownum与order by 混合使用时，如果直接使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">11</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name;</span><br></pre></td></tr></table></figure><p>可能每次都会生成不同的结果，正确的使用方法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">   (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id)</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt; <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>详细参考：<a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns009.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/B19306_01/server.102/b14200/pseudocolumns009.htm</a></p><h6 id="8-LIKE-CLAUSE"><a href="#8-LIKE-CLAUSE" class="headerlink" title="8 LIKE CLAUSE"></a>8 LIKE CLAUSE</h6><p>like的使用语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> pattern;</span><br></pre></td></tr></table></figure><p>like的模式匹配中，通常可以有如下的2个符号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The pattern can contain special pattern-matching characters:</span><br><span class="line"></span><br><span class="line">An underscore (_) <span class="keyword">in</span> the pattern matches exactly one character (as opposed to one byte <span class="keyword">in</span> a multibyte character <span class="built_in">set</span>) <span class="keyword">in</span> the value.</span><br><span class="line"></span><br><span class="line">A percent sign (%) <span class="keyword">in</span> the pattern can match zero or more characters (as opposed to bytes <span class="keyword">in</span> a multibyte character <span class="built_in">set</span>) <span class="keyword">in</span> the value. The pattern <span class="string">'%'</span> cannot match a null.</span><br></pre></td></tr></table></figure><p>关于Like的更多用法（<strong>设置转义字符</strong>等等），请参考官方的文档：</p><p><a href="https://docs.oracle.com/cd/B13789_01/server.101/b10759/conditions016.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/B13789_01/server.101/b10759/conditions016.htm</a></p><h6 id="9-别名-Alias"><a href="#9-别名-Alias" class="headerlink" title="9 别名 Alias"></a>9 别名 Alias</h6><p>对于MySQL来说，使用<strong>AS</strong>，来起到别名的作用。</p><p><strong>存在表别名与列的别名。</strong></p><p>在Oracle的帮助文档中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Oracle ALIASES can be used to create a temporary name <span class="keyword">for</span> columns or tables.</span><br><span class="line"></span><br><span class="line">COLUMN ALIASES are used to make column headings <span class="keyword">in</span> your result <span class="built_in">set</span> easier to <span class="built_in">read</span>.</span><br><span class="line">TABLE ALIASES are used to shorten your SQL to make it easier to <span class="built_in">read</span> or when you are performing a self join (ie: listing the same table more than once <span class="keyword">in</span> the FROM clause).</span><br></pre></td></tr></table></figure><p>列的别名使得查询结果更加易读。表的别名，可以使得SQL语句更加简短尤其是当实现Self Join。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">column_name AS alias_name</span><br><span class="line">table_name alias_name</span><br></pre></td></tr></table></figure><p>在Oracle中，实际在测试中发现，对于表，不能加as，对于列，可以加可不加。</p><p>需要注意的几个事项：</p><ul><li>If the <em>alias_name</em> contains spaces, you must enclose the <em>alias_name</em> in quotes.</li><li>It is acceptable to use spaces when you are aliasing a column name. However, it is not generally good practice to use spaces when you are aliasing a table name.</li><li>The <em>alias_name</em> is only valid within the scope of the SQL statement.</li></ul><p><strong>别名只在当前的SQL语句中有效。</strong></p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> contact_id, first_name || last_name <span class="keyword">AS</span> <span class="keyword">NAME</span></span><br><span class="line"><span class="keyword">FROM</span> contacts</span><br><span class="line"><span class="keyword">WHERE</span> last_name = <span class="string">'Anderson'</span>;</span><br></pre></td></tr></table></figure><p>表的别名在表Join时应用更加凸显：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.product_id, p.product_name, categories.category_name</span><br><span class="line"><span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> categories</span><br><span class="line"><span class="keyword">ON</span> p.category_id = categories.category_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> p.product_name <span class="keyword">ASC</span>, categories.category_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>参考如下的连接：<a href="https://www.techonthenet.com/oracle/alias.php" target="_blank" rel="noopener">https://www.techonthenet.com/oracle/alias.php</a></p><h6 id="10-JOIN联表查询"><a href="#10-JOIN联表查询" class="headerlink" title="10 JOIN联表查询"></a>10 JOIN联表查询</h6><p>There are 4 different types of Oracle joins:</p><ul><li><p>Oracle INNER JOIN (or sometimes called simple join)</p></li><li><p>Oracle LEFT OUTER JOIN (or sometimes called LEFT JOIN)</p></li><li><p>Oracle RIGHT OUTER JOIN (or sometimes called RIGHT JOIN)</p></li><li><p>Oracle FULL OUTER JOIN (or sometimes called FULL JOIN)</p></li></ul><p>Inner Join：根据联合条件，选择两表中的共有的value。</p><p>在实际操作时，需要注意排列组合的实现：表 <strong>hobby</strong>的数据如下：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1554625808204f6rtvm2c.png?imageslim" alt="paste image"></p><p>表 <strong>lessons</strong>的数据如下：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1554625884152e7t4rr7i.png?imageslim" alt="paste image"></p><p>执行的联表的语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> h.sname,h.hoby,l.lesson <span class="keyword">from</span> hobby h <span class="keyword">inner</span> <span class="keyword">join</span> lessons l <span class="keyword">on</span> h.sname = l.sname;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1554626227882wympqob5.png?imageslim" alt="paste image"></p><p><strong>由此可以推知：Inner Join会以内联字段作为桥梁，进行排列组合式的联结。</strong></p><p>Left Join：左联。<strong>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</strong></p><p>Right Join:  右联。<strong>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</strong></p><p><strong>左联与右联主要差别在于，以哪张表为基础，去另外一张表中寻找数据。注意，在寻找数据时，不是一一对应的关系，也可能出现排列组合的方式。</strong></p><p>FULL JOIN：全联结。相当于左联结与右联结的并集。</p><h6 id="11-Union-amp-amp-Union-ALL"><a href="#11-Union-amp-amp-Union-ALL" class="headerlink" title="11 Union &amp;&amp; Union ALL"></a>11 Union &amp;&amp; Union ALL</h6><p>Union用于将不同的查询结果进行合并：</p><p><strong>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</strong></p><p>Union 与 union all的区别在于，union相当于distinct，而union all是包含重复的项。</p><h6 id="12-Select-into"><a href="#12-Select-into" class="headerlink" title="12 Select into"></a>12 Select into</h6><p>Select into 语句从1个或者多个数据库表中获取数据，并且将select的值分配到变量或者集合。</p><p> <strong>In its default usage (<code>SELECT ... INTO</code>), this statement retrieves one or more columns from a single row</strong></p><p> <strong>In its bulk usage (<code>SELECT ... BULK COLLECT INTO</code>), this statement retrieves an entire result set at once.</strong></p><p>默认select into从单行中截取数据，可以截取多列，如果有多行的数据返回，则会报错：<strong>TOO_MANY_ROWS</strong>，例如下格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,sno <span class="keyword">into</span> l_name,l_cnt <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">9527</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> l_cnt，l_name <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line">TYPE stu_record IS RECORD(</span><br><span class="line">         SNO NUMBER,</span><br><span class="line">         Name VARCHAR2(32)</span><br><span class="line">         );</span><br><span class="line">rec1 stu_record;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> rec1 <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">9527</span>;</span><br></pre></td></tr></table></figure><p>使用select into时，需要注意异常的捕捉：</p><p>一个参考的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">declare </span><br><span class="line">  TYPE stu_record IS RECORD(</span><br><span class="line">         SNO NUMBER,</span><br><span class="line">         Name VARCHAR2(32)</span><br><span class="line">         );</span><br><span class="line">         </span><br><span class="line">  l_cnt number := 0;</span><br><span class="line">  l_name varchar2(32) := &apos;&apos;;</span><br><span class="line">  </span><br><span class="line">  rec1 stu_record;</span><br><span class="line"> </span><br><span class="line">begin</span><br><span class="line">  select * into rec1 from student where sno = 9910;</span><br><span class="line">  dbms_output.put_line(rec1.SNO || &apos; is the number of lines&apos; || rec1.Name);</span><br><span class="line">exception</span><br><span class="line">  when no_data_found or too_many_rows then</span><br><span class="line">    dbms_output.put_line(&apos;error found&apos;);</span><br><span class="line">  when others then</span><br><span class="line">    dbms_output.put_line(&apos;other error found&apos;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p><strong>If no rows are returned, PL/SQL raises <code>NO_DATA_FOUND</code>. You can guard against this exception by selecting the result of an aggregate function, such as <code>COUNT(*)</code> or <code>AVG()</code>, where practical.</strong> </p><p><strong>These functions are guaranteed to return a single value, even if no rows match the condition.</strong></p><p>对于 <code>SELECT ... BULK COLLECT INTO</code> ,返回的是多行数据吗，需要set up集合变量来存储结果，<strong>You can declare associative arrays or nested tables that grow as needed to hold the entire result set.</strong></p><h6 id="13-存储过程-调试方法"><a href="#13-存储过程-调试方法" class="headerlink" title="13 存储过程 调试方法"></a>13 存储过程 调试方法</h6><p>直接在SQL窗口中，是无法进行调试的，需要进入到“测试窗口”才可以进行，即使是存储过程和包，都是需要进入到测试窗口。</p><p>进入测试窗口的方法：“<strong>新建</strong>”–》“<strong>测试窗口</strong>”。调试时，可以看到调试输出信息。</p><p>如果提示：ORA-0131 :insufficient privileges DEBUG CONNECT SESSION</p><p>则表示当前的用户没有Debug权限，则需要使用系统用户进行授权，授权的脚本为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> DEBUG <span class="keyword">CONNECT</span> <span class="keyword">SESSION</span> <span class="keyword">to</span> scott</span><br></pre></td></tr></table></figure><h6 id="14-SQL-Subqueries-子查询"><a href="#14-SQL-Subqueries-子查询" class="headerlink" title="14  SQL Subqueries(子查询)"></a>14  SQL Subqueries(子查询)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In Oracle, a subquery is a query within a query. You can create subqueries within your SQL statements. These subqueries can reside in the WHERE clause, the FROM clause, or the SELECT clause.</span><br></pre></td></tr></table></figure><p>子查询即查询中的查询。可以驻留在<strong>where</strong>、<strong>from</strong>、<strong>select</strong>子句中。</p><p>在Where子句中，是最常见的场景 nested subqueries：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM all_tables tabs</span><br><span class="line">WHERE tabs.table_name IN (SELECT cols.table_name</span><br><span class="line">                          FROM all_tab_columns cols</span><br><span class="line">                          WHERE cols.column_name = &apos;SUPPLIER_ID&apos;);</span><br></pre></td></tr></table></figure><p>Oracle allows up to <strong>255</strong> levels of subqueries in the WHERE clause.</p><p>from子句中的场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT suppliers.name, subquery1.total_amt</span><br><span class="line">FROM suppliers,</span><br><span class="line"> (SELECT supplier_id, SUM(orders.amount) AS total_amt</span><br><span class="line">  FROM orders</span><br><span class="line">  GROUP BY supplier_id) subquery1</span><br><span class="line">WHERE subquery1.supplier_id = suppliers.supplier_id;</span><br></pre></td></tr></table></figure><p>这又被叫做 inline views，与inner join异曲同工。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select student.sname,hobby.shobby from student,hobby where student.sno = hobby.sno</span><br><span class="line">select student.sname,hobby.shobby from student inner join hobby on  student.sno = hobby.sno;</span><br></pre></td></tr></table></figure><p>Select 子句场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT tbls.owner, tbls.table_name,</span><br><span class="line">  (SELECT COUNT(column_name) AS total_columns</span><br><span class="line">   FROM all_tab_columns cols</span><br><span class="line">   WHERE cols.owner = tbls.owner</span><br><span class="line">   AND cols.table_name = tbls.table_name) subquery2</span><br></pre></td></tr></table></figure><p>The subquery has been aliased with the name <em>subquery2</em>. This will be the name used to reference this subquery or any of its fields.</p><p><strong>The trick to placing a subquery in the select clause is that the subquery must return a single value</strong>. This is why an aggregate function such as <a href="https://www.techonthenet.com/oracle/functions/sum.php" target="_blank" rel="noopener">SUM function</a>, <a href="https://www.techonthenet.com/oracle/functions/count.php" target="_blank" rel="noopener">COUNT function</a>, <a href="https://www.techonthenet.com/oracle/functions/min.php" target="_blank" rel="noopener">MIN function</a>, or <a href="https://www.techonthenet.com/oracle/functions/max.php" target="_blank" rel="noopener">MAX function</a> is commonly used in the subquery.</p><p>如果要在select 子句中添加子句，要保证返回的值是一个单个的值。</p><h6 id="15-Collection-集合"><a href="#15-Collection-集合" class="headerlink" title="15  Collection 集合"></a>15  Collection 集合</h6><p>学习参考：<a href="https://www.tutorialspoint.com/plsql/plsql_collections.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/plsql/plsql_collections.htm</a></p><p><a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/05_colls.htm#20425" target="_blank" rel="noopener">https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/05_colls.htm#20425</a></p><p>PLSQL有3种类型的集合。</p><p>PL/SQL provides three collection types</p><ul><li><p>Index-by tables or Associative array</p></li><li><p>Nested table</p></li><li><p>Variable-size array or Varray</p></li></ul><h6 id="16-From-table-to-table"><a href="#16-From-table-to-table" class="headerlink" title="16 From table to table"></a>16 From table to table</h6><p>1）<strong>INSERT INTO SELECT</strong> </p><p>从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p><p>在插入时，要需要注意待插入表的约束的情况。示例的一个插入语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">select</span> * <span class="keyword">from</span> STUDENT_BAK b <span class="keyword">where</span> b.sno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> sno <span class="keyword">from</span> student)</span><br></pre></td></tr></table></figure><p>2) <strong>create  table as select</strong> </p><p>新建的表要求不存在，创建一个新表，从一个表中的数据复制另外一个表中的数据。<strong>但是这种方式只会保留数据，表的约束并不会同步过来。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table student_bak as select * from STUDENT t;</span><br></pre></td></tr></table></figure><h6 id="17-View视图"><a href="#17-View视图" class="headerlink" title="17 View视图"></a>17 View视图</h6><p>参考如下的连接：<a href="https://www.techonthenet.com/oracle/views.php" target="_blank" rel="noopener">https://www.techonthenet.com/oracle/views.php</a></p><p>View与Table的区别点摘抄如下：</p><p>区别：</p><p>​      1、视图是已经编译好的sql语句。而表不是<br>​      2、视图没有实际的物理记录。而表有。<br>​      3、表是内容，视图是窗口<br>​      4、表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改<br>​      5、表是内模式，视图是外模式<br>​      6、视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。<br>​      7、表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。 </p><p>​     8、视图的建立与删除只影响视图本身，不影响对应的基本表。</p><p>联系：<strong>视图（view）是在基本表之上建立的表</strong>，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。</p><p>​      一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p><p>在普通用户下创建view时，会提示权限不足，可以使用如下的指令在sysdba模式下授权：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">view</span> <span class="keyword">to</span> scott</span><br></pre></td></tr></table></figure><p><strong>View的创建</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">columns</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line">  [<span class="keyword">WHERE</span> conditions];</span><br></pre></td></tr></table></figure><p>​    where语句是可选的，其条件必须要被view_name中的视图所满足。</p><p><strong>View的更新</strong>：</p><p>可以在不drop view的前提下更新一个Oracle的View的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE or REPLACE VIEW sup_orders AS</span><br><span class="line">  SELECT suppliers.supplier_id, orders.quantity, orders.price</span><br><span class="line">  FROM suppliers</span><br><span class="line">  INNER JOIN orders</span><br><span class="line">  ON suppliers.supplier_id = orders.supplier_id</span><br><span class="line">  WHERE suppliers.supplier_name = &apos;Apple&apos;;</span><br></pre></td></tr></table></figure><p>这句话的命令是不存在则创建，存在则更新一个View。</p><p>如果直接更新一个view，可能会影响到实际的数据。</p><p><strong>Question:</strong> Can you update the data in an Oracle VIEW?</p><p><strong>Answer:</strong> A VIEW in Oracle is created by joining one or more tables. When you update record(s) in a VIEW, it updates the records in the underlying tables that make up the View.</p><p>So, yes, you can update the data in an Oracle VIEW providing you have the proper privileges to the underlying Oracle tables.</p><p><strong>View的删除</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW sup_orders;</span><br></pre></td></tr></table></figure><p>注意，删除了view，这个view所依赖的表不会有影响。<br>类似的，删除了表，这个view依旧会存在，只是在使用时会提示数据错误问题。</p><h6 id="18-函数"><a href="#18-函数" class="headerlink" title="18 函数"></a>18 函数</h6><p>Oracle标准的内建函数参见如下的列表：</p><p><a href="https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj55788.html" target="_blank" rel="noopener">https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj55788.html</a></p><p>聚合函数：Aggregates (set functions)：</p><p><a href="https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj33923.html" target="_blank" rel="noopener">https://docs.oracle.com/javadb/10.8.3.0/ref/rrefsqlj33923.html</a></p><h6 id="19-Group-by"><a href="#19-Group-by" class="headerlink" title="19 Group by"></a>19 Group by</h6><p>参考链接：<a href="https://www.techonthenet.com/oracle/group_by.php" target="_blank" rel="noopener">https://www.techonthenet.com/oracle/group_by.php</a></p><p><strong>The Oracle GROUP BY clause is used in a<a href="https://www.techonthenet.com/oracle/select.php" target="_blank" rel="noopener"> SELECT statement</a> to collect data across multiple records and group the results by one or more columns.</strong></p><p>group by经常与聚合函数一起使用。In this case, the aggregate function returns the summary information per group。在此情况下，聚合函数返回的是每个组的sum信息。</p><p>The <code>GROUP BY</code> clause must contain only aggregates or grouping columns.</p><p>group by只能包含聚合的列。</p><p>Group By有一个比较好的作用，在于去重。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sno,sname from  stu_bak group by sno, sname</span><br></pre></td></tr></table></figure><p>通用的一个Group by的表达式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n, </span><br><span class="line">       aggregate_function (aggregate_expression)</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">GROUP BY expression1, expression2, ... expression_n;</span><br></pre></td></tr></table></figure><p>注意几个约束条件：</p><p>1）<strong>The expressions that are not encapsulated within an aggregate function and must be included in the GROUP BY clause</strong></p><p>未出现在聚合函数中的expression必须要包含在group by子句中。</p><p>2）<strong>aggregate_function</strong> It can be a function such as<a href="https://www.techonthenet.com/oracle/functions/sum.php" target="_blank" rel="noopener"> SUM</a>,<a href="https://www.techonthenet.com/oracle/functions/count.php" target="_blank" rel="noopener"> COUNT</a>,<a href="https://www.techonthenet.com/oracle/functions/min.php" target="_blank" rel="noopener"> MIN</a>,<a href="https://www.techonthenet.com/oracle/functions/max.php" target="_blank" rel="noopener"> MAX</a>, or <a href="https://www.techonthenet.com/oracle/functions/avg.php" target="_blank" rel="noopener">AVG</a> functions.</p><p>3）<strong>aggregate_expression</strong>：This is the column or expression that the <em>aggregate_function</em> will be used on.</p><p>4）<strong>tables</strong>：The tables that you wish to retrieve records from. There must be at least one table listed in the FROM clause.</p><p>5）<strong>WHERE conditions</strong>：Optional. The conditions that must be met for the records to be selected.</p><p>Group中<code>aggregate_function</code>可以认为是对<strong>group分组的操作</strong>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sname,count(*) from stu_bak group by sname;</span><br></pre></td></tr></table></figure><p>此处的count(<em>)并非是整个表的数量，上述的语句的含义为：按照sname进行分组，并对分组执行count(\</em>)，统计分组的数量。</p><h6 id="20-Having子句"><a href="#20-Having子句" class="headerlink" title="20 Having子句"></a>20 Having子句</h6><p>having子句需要与Group by一起使用，<strong>作用是对group的分组再次进行筛选</strong>。</p><p>只对聚合的结果进行筛选。</p><p>The Oracle HAVING clause is used in combination with the<a href="https://www.techonthenet.com/oracle/group_by.php" target="_blank" rel="noopener"> GROUP BY clause</a> to restrict the groups of returned rows to only those whose the condition is TRUE.</p><p>使用的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n, </span><br><span class="line">       aggregate_function (aggregate_expression)</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">GROUP BY expression1, expression2, ... expression_n</span><br><span class="line">HAVING having_condition;</span><br></pre></td></tr></table></figure><p>在Group by的约束后，又增加了如下的一个：</p><p><strong>having_condition</strong>：This is a further condition applied only to the <strong>aggregated results</strong> to restrict the groups of returned rows. Only those groups whose condition evaluates to TRUE will be included in the result set.</p><p>是对聚合的结果的约束加强。示例的脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> partment,<span class="keyword">sum</span>(salary) <span class="keyword">from</span> EMPLOYEE t  <span class="keyword">group</span> <span class="keyword">by</span> partment <span class="keyword">having</span> <span class="keyword">sum</span>(sales)&gt;=<span class="number">30</span> ;</span><br></pre></td></tr></table></figure><h6 id="21-DUAL表"><a href="#21-DUAL表" class="headerlink" title="21 DUAL表"></a>21 DUAL表</h6><p>dual表是由Oracle数据库自动创建的一张表，本质上dual属于sys schema，但是其他的非SYS用户可以访问，其有其自身的列：<strong>DUMMY</strong>，且其值为：X，其类型为 <strong>VARCHAR2()</strong></p><p>常用在无特定表的Select查询。</p><blockquote><p>Selecting from the <code>DUAL</code> table is useful for computing a constant expression with the <code>SELECT</code> statement. </p></blockquote><p>在网上查询到，使用这个表可以如下的事情：</p><p>1）查询当前的用户：select user from dual</p><p>2）调用系统函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual   获得当前系统时间</span><br><span class="line">select SYS_CONTEXT(&apos;USERENV&apos;,&apos;TERMINAL&apos;) from dual   获得主机名</span><br><span class="line">select SYS_CONTEXT(&apos;USERENV&apos;,&apos;language&apos;) from dual  获得当前locale</span><br><span class="line">select dbms_random.random from dual     获得一个随机数</span><br><span class="line">select 3+5 as add_value,5+7 as sub_value from dual;    计算结果后，保存到不同的列值中</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;MySQL-DDL-amp-amp-DML-温故知新&quot;&gt;&lt;a href=&quot;#MySQL-DDL-amp-amp-DML-温故知新&quot; class=&quot;headerlink&quot; title=&quot;MySQL DDL&amp;amp;&amp;amp;DML 温故知新&quot;&gt;&lt;/a&gt;MySQL D
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP、UDP、Port、Socket 温故知新</title>
    <link href="http://yoursite.com/2019/03/25/TCP/"/>
    <id>http://yoursite.com/2019/03/25/TCP/</id>
    <published>2019-03-25T08:17:45.000Z</published>
    <updated>2019-03-25T08:18:04.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCP、UDP、Port、Socket-温故知新"><a href="#TCP、UDP、Port、Socket-温故知新" class="headerlink" title="TCP、UDP、Port、Socket 温故知新"></a>TCP、UDP、Port、Socket 温故知新</h4><h5 id="0-序"><a href="#0-序" class="headerlink" title="0.序"></a>0.序</h5><p>本文主要参考：<a href="http://www.steves-internet-guide.com/tcpip-ports-sockets/" target="_blank" rel="noopener">http://www.steves-internet-guide.com/tcpip-ports-sockets/</a></p><p>是迄今见过讲解最易懂的文章。</p><h5 id="1-TCP、UDP的区别"><a href="#1-TCP、UDP的区别" class="headerlink" title="1 TCP、UDP的区别"></a>1 TCP、UDP的区别</h5><p>TCP与UDP是传输层的协议，其上一层是应用层。</p><p>在<code>package</code>层面，TCP与UDP的封包的头有所不同。</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1553323825805h3m9fyh5.png?imageslim" alt="paste image"></p><p>在很多资料中，都有提到TCP与UDP的区别：</p><h6 id="1）-TCP的特征"><a href="#1）-TCP的特征" class="headerlink" title="1） TCP的特征"></a>1） TCP的特征</h6><p><img src="http://pogngdcwy.bkt.clouddn.com/1553324079849p5my18w0.png?imageslim" alt="paste image"></p><p>其中，对于“Connection-Oriented”的理解，参考WIki百科（<a href="https://en.wikipedia.org/wiki/Connection-oriented_communication）：" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Connection-oriented_communication）：</a></p><blockquote><p><strong>Connection-oriented communication</strong> is a network communication mode in <a href="https://en.wikipedia.org/wiki/Telecommunication" target="_blank" rel="noopener">telecommunications</a> and computer networking, where a <a href="https://en.wikipedia.org/wiki/Communication_session" target="_blank" rel="noopener">communication session</a> or a semi-permanent connection is established before any useful data can be transferred, and where a stream of data is delivered in the same order as it was sent[<em>citation needed</em>].</p></blockquote><p>面向连接的通信方式在数据传输之前，需要先establish a connection。这也就意味着，在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p>命令查看到的连接，将是TCP的连接。</p><p>一个输出结果示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Clark&gt;netstat -ano</span><br><span class="line"></span><br><span class="line">活动连接</span><br><span class="line"></span><br><span class="line">  协议  本地地址          外部地址        状态           PID</span><br><span class="line">  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       524</span><br><span class="line">  TCP    0.0.0.0:443            0.0.0.0:0              LISTENING       6748</span><br><span class="line">  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4</span><br><span class="line">  TCP    0.0.0.0:902            0.0.0.0:0              LISTENING       4972</span><br><span class="line">  TCP    0.0.0.0:912            0.0.0.0:0              LISTENING       4972</span><br><span class="line">  TCP    0.0.0.0:5040           0.0.0.0:0              LISTENING       7236</span><br><span class="line">  TCP    0.0.0.0:5357           0.0.0.0:0              LISTENING       4</span><br><span class="line">  TCP    0.0.0.0:11301          0.0.0.0:0              LISTENING       6692</span><br><span class="line">  TCP    0.0.0.0:20831          0.0.0.0:0              LISTENING       8788</span><br><span class="line">  TCP    0.0.0.0:49664          0.0.0.0:0              LISTENING       648</span><br><span class="line">  TCP    0.0.0.0:49665          0.0.0.0:0              LISTENING       1544</span><br><span class="line">  TCP    0.0.0.0:49666          0.0.0.0:0              LISTENING       1768</span><br><span class="line">  TCP    0.0.0.0:49667          0.0.0.0:0              LISTENING       2896</span><br><span class="line">  TCP    0.0.0.0:49668          0.0.0.0:0              LISTENING       3188</span><br><span class="line">  TCP    0.0.0.0:49669          0.0.0.0:0              LISTENING       796</span><br><span class="line">  TCP    0.0.0.0:49708          0.0.0.0:0              LISTENING       772</span><br><span class="line">  TCP    0.0.0.0:50054          0.0.0.0:0              LISTENING       13104</span><br><span class="line">  TCP    127.0.0.1:443          127.0.0.1:52734        ESTABLISHED     6748</span><br><span class="line">  TCP    127.0.0.1:443          127.0.0.1:53039        ESTABLISHED     6748</span><br><span class="line">  TCP    127.0.0.1:4300         0.0.0.0:0              LISTENING       13104</span><br><span class="line">  TCP    127.0.0.1:4301         0.0.0.0:0              LISTENING       13104</span><br><span class="line">  TCP    127.0.0.1:5939         0.0.0.0:0              LISTENING       3720</span><br><span class="line">  TCP    172.254.40.135:53702   172.20.30.83:3389      ESTABLISHED     22664</span><br></pre></td></tr></table></figure><p><strong>从上图可以看出，本机的一些端口处于侦听状态（Listening），有些端口处于连接状态（Established）</strong>。</p><p>例如最后一行，<strong>172.254.40.135</strong>作为客户端连接到<strong>172.20.30.183</strong>的<strong>3389</strong>端口。</p><p>通过数字的大小，可以初步判断相对应的客户端和服务端。</p><h6 id="2）-UDP的特征"><a href="#2）-UDP的特征" class="headerlink" title="2） UDP的特征"></a>2） UDP的特征</h6><p><img src="http://pogngdcwy.bkt.clouddn.com/1553325130106bqbu1r52.png?imageslim" alt="paste image"></p><p>UDP是一种<strong>Try Best Effort</strong>尽力传输的方式，不保证数据的可靠传输，丢了就丢了。</p><p>在传输之前，是不需要事先建立连接的。</p><p>UDP适用于传输少量数据，对于可靠性要求不高的环境，例如<strong>ping</strong>来检查网络的连通性，发送的就是UDP报文。</p><p>且因为UDP不需要握手建立连接以及ACK确认包的传输情况，所以传输速度很快，例如QQ传文件使用的就是UDP。</p><p>TCP适用于传输大量的数据，且对可靠性要求较高的环境。</p><h5 id="2-Port-端口分布特征"><a href="#2-Port-端口分布特征" class="headerlink" title="2 Port 端口分布特征"></a>2 Port 端口分布特征</h5><p>首先思考一个问题：<strong>为什么要有端口？</strong> <strong>为什么光有IP地址不行？</strong></p><p>IP地址相当于是网络中的计算机的身份中，是用来进行身份识别的标记。</p><p>如果主机中运行了多个应用程序，客户端将如何识别这些不同的服务呢？这个时候，采用的是端口的机制。</p><p>引用一段描述：</p><blockquote><p><strong>The use of ports allow computers/devices to run multiple services/applications*</strong>.*</p></blockquote><p>TCP/IP协议的端口是有其特征的：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1553325572416bdzomu9c.png?imageslim" alt="paste image"></p><p><strong>服务端与客户端的端口的使用是有差异的，对于服务器端而言，一般使用的是永久的端口，不会随着请求的变化而变化，而客户端而言，使用的是临时端口</strong></p><p><img src="http://pogngdcwy.bkt.clouddn.com/1553326014363qxzjszim.png?imageslim" alt="paste image"></p><p>TCP与UDP在Header中，有2个字节标志Port Number，因此其范围是<strong>0~65535</strong></p><p>一般情况下，服务端的端口需要被广而告之，这样客户端才能使用其服务。</p><p>关于端口的一段描述如下：</p><blockquote><p><strong>Port numbers 0-1023 – Well known ports.</strong> These are allocated to <strong>server services</strong> by the <strong>Internet Assigned Numbers Authority</strong> (IANA). e.g Web servers normally use <strong>port 80</strong> and SMTP servers use <strong>port 25</strong> (see diagram above).</p><p><strong>Ports 1024-49151- Registered Port</strong> -These can be registered for services with the <strong>IANA</strong> and should be treated as <strong>semi-reserved.</strong> User written programs should not use these ports.</p><p><strong>Ports 49152-65535</strong>– These are used by <strong>client programs</strong> and you are free to use these in client programs. When a Web browser connects to a web server the browser will allocate itself a port in this range. Also known as <strong>ephemeral ports</strong>.</p></blockquote><p><strong>TCP与UDP的端口号是完全分离的。</strong></p><p>一些比较有意思的现象：</p><p>有的服务需要占用相同协议的不同端口：<strong>FTP TCP/20 (data)，TCP/21 (control)</strong> </p><p>有的服务不同协议的相同端口：<strong>DNS TCP/53（zone transfer）,UDP/53 (client query)</strong></p><p><img src="http://pogngdcwy.bkt.clouddn.com/1553326410168bin01dni.png?imageslim" alt="paste image"></p><p>知名的UDP服务端口，包括TFTP、DHCP协议等。</p><p><img src="http://pogngdcwy.bkt.clouddn.com/15533268903407rf8t712.png?imageslim" alt="paste image"></p><h5 id="3-Socket的认识"><a href="#3-Socket的认识" class="headerlink" title="3 Socket的认识"></a>3 Socket的认识</h5><p>精华：<strong>Socket = IP + Port</strong></p><blockquote><p><strong>A connection between two computers uses</strong> a <strong>socket.</strong></p></blockquote><p><img src="http://www.steves-internet-guide.com/wp-content/uploads/TCP-IP-ports-sockets.jpg" alt="socket定义"></p><p>2台主机之间进行连接，使用的是socket。可以将连接认为是2端的Socket之间的连接。</p><p>在许多的编程语言中，Socket也是编程应用的对象。</p><h5 id="4-netstat的使用方法"><a href="#4-netstat的使用方法" class="headerlink" title="4 netstat的使用方法"></a>4 netstat的使用方法</h5><p>Linux和Windows中，都有netstat命令，现在以Windows为例。</p><p>对于netstat的命令的使用，参考如下的连接：<a href="https://sites.google.com/site/xiangyangsite/home/technical-tips/linux-unix/networks-related-commands-on-linux/how-to-read-netstat--an-results" target="_blank" rel="noopener">How to read NETSTAT -AN results</a></p><p>可以看出主机的侦听的端口以及连接的远程端口的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TCP、UDP、Port、Socket-温故知新&quot;&gt;&lt;a href=&quot;#TCP、UDP、Port、Socket-温故知新&quot; class=&quot;headerlink&quot; title=&quot;TCP、UDP、Port、Socket 温故知新&quot;&gt;&lt;/a&gt;TCP、UDP、Port、S
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VSCode与Git联合使用方法</title>
    <link href="http://yoursite.com/2019/03/21/VSCode%E4%B8%8EGit%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/21/VSCode与Git联合使用方法/</id>
    <published>2019-03-21T05:44:54.000Z</published>
    <updated>2019-05-31T08:09:05.883Z</updated>
    
    <content type="html"><![CDATA[<h4 id="VSCode与Git联合使用方法"><a href="#VSCode与Git联合使用方法" class="headerlink" title="VSCode与Git联合使用方法"></a>VSCode与Git联合使用方法</h4><h5 id="1-Git的安装"><a href="#1-Git的安装" class="headerlink" title="1 Git的安装"></a>1 Git的安装</h5><p>在Windows环境下，可以安装Git的可执行文件来获得Git环境。可以直接Google Git的官网，下载最新版本的程序，按照prompt一一安装即可。</p><h6 id="1）git-config全局配置"><a href="#1）git-config全局配置" class="headerlink" title="1）git config全局配置"></a>1）git config全局配置</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">git config --global user.email  <span class="string">"name@qq.com"</span></span><br></pre></td></tr></table></figure><p>最终配置，将会保存在文件 <code>.gitconfig</code>中。如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.gitconfig</span><br><span class="line">[user]</span><br><span class="line">        name = wuxinhong</span><br><span class="line">        email = wuxinhong@somesite.com.cn</span><br></pre></td></tr></table></figure><p>注入其他的全局配置，如http.proxy代理等，都可以使用相类似的方法进行设置。</p><p>在指定目录下启动Gitbash的方法为：在窗口区，点击右键，单击<strong>Git bash Here</strong></p><p><img src="http://pogngdcwy.bkt.clouddn.com/1553087522877741tqn2j.png?imageslim" alt="paste image"></p><h6 id="2-git-clone-URL地址"><a href="#2-git-clone-URL地址" class="headerlink" title="2) git clone URL地址"></a>2) git clone URL地址</h6><p>因为公司的码云仓库需要进行鉴权，<strong>经过一番摸索后，发现要在 git clone中指定username，才能成功下载代码。</strong></p><p>命令的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://wuxinhong</span><br></pre></td></tr></table></figure><p><strong>本质上，是在原先的HTTP的地址中，增加了username</strong></p><p>原始的URL地址是：</p><h5 id="2-VSCode上库流程"><a href="#2-VSCode上库流程" class="headerlink" title="2 VSCode上库流程"></a>2 VSCode上库流程</h5><h6 id="1）打开git代码目录"><a href="#1）打开git代码目录" class="headerlink" title="1）打开git代码目录"></a>1）打开git代码目录</h6><p>下载完Git仓库后，会有一个文件夹<strong>.git</strong>生成，这个目录将会被<strong>VSCode</strong>识别。</p><h6 id="2）修改代码"><a href="#2）修改代码" class="headerlink" title="2）修改代码"></a>2）修改代码</h6><p>在VSCode中修改代码后，在工程中将会出现Change提示符号，如下图所示：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1553088323397e3koel23.png?imageslim" alt="paste image"></p><h6 id="3）提交修改"><a href="#3）提交修改" class="headerlink" title="3）提交修改"></a>3）提交修改</h6><p>提交修改时，可以直接点击提交按钮，会提示添加Commit信息。然后再点击<code>...</code>push到对应的分支，如下图所示：</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1553146529100fuzx5zg5.png?imageslim" alt="paste image"></p><h5 id="3-Pull-Request的玩法"><a href="#3-Pull-Request的玩法" class="headerlink" title="3 Pull Request的玩法"></a>3 Pull Request的玩法</h5><p>首先需要认识到：<strong>git clone下载下来的是全套的代码，包含所有的分支</strong>，因此可以使用<strong>git checkout branch</strong> 来进行分支的切换。</p><p>因此，在开发时，切换到dev分支，并且将代码上库到dev分支。然后在GitHub中提起Pull Request。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;VSCode与Git联合使用方法&quot;&gt;&lt;a href=&quot;#VSCode与Git联合使用方法&quot; class=&quot;headerlink&quot; title=&quot;VSCode与Git联合使用方法&quot;&gt;&lt;/a&gt;VSCode与Git联合使用方法&lt;/h4&gt;&lt;h5 id=&quot;1-Git的安装&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python 调试技巧</title>
    <link href="http://yoursite.com/2019/03/20/Python-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/03/20/Python-调试技巧/</id>
    <published>2019-03-20T05:28:57.000Z</published>
    <updated>2019-03-20T05:29:03.019Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Python-调试技巧"><a href="#Python-调试技巧" class="headerlink" title="Python 调试技巧"></a>Python 调试技巧</h4><h5 id="1-pdb-单步跟踪"><a href="#1-pdb-单步跟踪" class="headerlink" title="1 pdb 单步跟踪"></a>1 pdb 单步跟踪</h5><p>类似Go/C语言的gdb，python也存在一个类似的单步调试器：pdb。</p><p>可以使用类似的用法，对Python程序进行调试。</p><p>启动pdb调试命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pdb file.py</span><br></pre></td></tr></table></figure><h5 id="2-python-函数原型"><a href="#2-python-函数原型" class="headerlink" title="2 python 函数原型"></a>2 python 函数原型</h5><p>C语言系统API，在Linux下，可以使用<code>man</code> 命令快速的查看函数的原型，例如：</p><p><code>man strcpy</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">STRCPY(<span class="number">3</span>)                                                                                                Linux Programmer'<span class="function">s Manual                                                                                               <span class="title">STRCPY</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">NAME</span></span><br><span class="line">       strcpy, strncpy - copy a string</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  strcpy()  function  copies  the  string pointed to by src, including the terminating null byte ('\0'), to the buffer pointed to by dest.  The strings may not overlap, and the destination string dest must be large enough to</span><br><span class="line">       receive the copy.  Beware of buffer overruns!  (See BUGS.)</span><br><span class="line"></span><br><span class="line">       The strncpy() function is similar, except that at most n bytes of src are copied.  Warning: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated.</span><br><span class="line"></span><br><span class="line">       If the length of src is less than n, <span class="built_in">strncpy</span>() writes additional null bytes to dest to ensure that a total of n bytes are written.</span><br><span class="line"></span><br><span class="line">       A simple implementation of strncpy() might be:</span><br><span class="line"></span><br><span class="line">           <span class="keyword">char</span> *</span><br><span class="line">           <span class="built_in">strncpy</span>(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; src[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">                   dest[i] = src[i];</span><br><span class="line">               <span class="keyword">for</span> ( ; i &lt; n; i++)</span><br><span class="line">                   dest[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> dest;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>​    在Python语言系统中，使用：<code>pydoc</code></p><p>​    例如，想查看json的dumps接口原型，可以输入：<code>pydoc json.dumps</code></p><p>​    会有如下的提示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Help on function dumps <span class="keyword">in</span> json:</span><br><span class="line"></span><br><span class="line">json.dumps = dumps(obj, skipkeys=<span class="literal">False</span>, ensure_ascii=<span class="literal">True</span>, check_circular=<span class="literal">True</span>, allow_nan=<span class="literal">True</span>, cls=<span class="literal">None</span>, indent=<span class="literal">None</span>, separators=<span class="literal">None</span>, encoding=<span class="string">'utf-8'</span>, default=<span class="literal">None</span>, sort_keys=<span class="literal">False</span>, **kw)</span><br><span class="line">    Serialize ``obj`` to a JSON formatted ``str``.</span><br><span class="line">    </span><br><span class="line">    If ``skipkeys`` <span class="keyword">is</span> true then ``dict`` keys that are <span class="keyword">not</span> basic types</span><br><span class="line">    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``<span class="literal">None</span>``)</span><br><span class="line">    will be skipped instead of raising a ``TypeError``.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    If ``ensure_ascii`` <span class="keyword">is</span> false, all non-ASCII characters are <span class="keyword">not</span> escaped, <span class="keyword">and</span></span><br><span class="line">    the <span class="keyword">return</span> value may be a ``unicode`` instance. See ``dump`` <span class="keyword">for</span> details.</span><br><span class="line">    </span><br><span class="line">    If ``check_circular`` <span class="keyword">is</span> false, then the circular reference check</span><br><span class="line">    <span class="keyword">for</span> container types will be skipped <span class="keyword">and</span> a circular reference will</span><br><span class="line">    result <span class="keyword">in</span> an ``OverflowError`` (<span class="keyword">or</span> worse).</span><br><span class="line">    </span><br><span class="line">    If ``allow_nan`` <span class="keyword">is</span> false, then it will be a ``ValueError`` to</span><br><span class="line">    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) <span class="keyword">in</span></span><br><span class="line">    strict compliance of the JSON specification, instead of using the</span><br><span class="line">    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).</span><br><span class="line">    </span><br><span class="line">    If ``indent`` <span class="keyword">is</span> a non-negative integer, then JSON array elements <span class="keyword">and</span></span><br><span class="line">    object members will be pretty-printed <span class="keyword">with</span> that indent level. An indent</span><br><span class="line">    level of <span class="number">0</span> will only insert newlines. ``<span class="literal">None</span>`` <span class="keyword">is</span> the most compact</span><br><span class="line">    representation.  Since the default item separator <span class="keyword">is</span> ``<span class="string">', '</span>``,  the</span><br><span class="line">    output might include trailing whitespace when ``indent`` <span class="keyword">is</span> specified.</span><br><span class="line">    You can use ``separators=(<span class="string">','</span>, <span class="string">': '</span>)`` to avoid this.</span><br><span class="line">    </span><br><span class="line">    If ``separators`` <span class="keyword">is</span> an ``(item_separator, dict_separator)`` tuple</span><br><span class="line">    then it will be used instead of the default ``(<span class="string">', '</span>, <span class="string">': '</span>)`` separators.</span><br><span class="line">    ``(<span class="string">','</span>, <span class="string">':'</span>)`` <span class="keyword">is</span> the most compact JSON representation.</span><br><span class="line">    </span><br><span class="line">    ``encoding`` <span class="keyword">is</span> the character encoding <span class="keyword">for</span> str instances, default <span class="keyword">is</span> UTF<span class="number">-8.</span></span><br><span class="line">    </span><br><span class="line">    ``default(obj)`` <span class="keyword">is</span> a function that should <span class="keyword">return</span> a serializable version</span><br><span class="line">    of obj <span class="keyword">or</span> <span class="keyword">raise</span> TypeError. The default simply raises TypeError.</span><br><span class="line">    </span><br><span class="line">    If *sort_keys* <span class="keyword">is</span> true (default: ``<span class="literal">False</span>``), then the output of</span><br><span class="line">    dictionaries will be sorted by key.</span><br><span class="line">    </span><br><span class="line">    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the</span><br><span class="line">    ``.default()`` method to serialize additional types), specify it <span class="keyword">with</span></span><br><span class="line">    the ``cls`` kwarg; otherwise ``JSONEncoder`` <span class="keyword">is</span> used.</span><br></pre></td></tr></table></figure><h5 id="3-python-包查找库"><a href="#3-python-包查找库" class="headerlink" title="3 python 包查找库"></a>3 python 包查找库</h5><p>​    类似于Go语言的Godoc，Python也有类似的网站：<a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org/</a></p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/1553059601588213uj3k1.png?imageslim" alt="paste image"></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Python-调试技巧&quot;&gt;&lt;a href=&quot;#Python-调试技巧&quot; class=&quot;headerlink&quot; title=&quot;Python 调试技巧&quot;&gt;&lt;/a&gt;Python 调试技巧&lt;/h4&gt;&lt;h5 id=&quot;1-pdb-单步跟踪&quot;&gt;&lt;a href=&quot;#1-pdb-单
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang json &amp;&amp; mysql Data Transfer</title>
    <link href="http://yoursite.com/2019/03/19/Golang-json-mysql-Data-Transfer/"/>
    <id>http://yoursite.com/2019/03/19/Golang-json-mysql-Data-Transfer/</id>
    <published>2019-03-19T06:02:33.000Z</published>
    <updated>2019-03-19T08:42:20.003Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Golang-json-amp-amp-mysql-Data-Transfer"><a href="#Golang-json-amp-amp-mysql-Data-Transfer" class="headerlink" title="Golang: json &amp;&amp; mysql Data Transfer"></a>Golang: json &amp;&amp; mysql Data Transfer</h4><h5 id="1-数据流转图"><a href="#1-数据流转图" class="headerlink" title="1 数据流转图"></a>1 数据流转图</h5><p>​    在常见的MVC的框架中，涉及到前端UI，后台服务，数据库存储三大块。从编程语言上看，前端使用JavaScript下发JSON数据，后台使用Golang（本项目是Golang）接收前端下发的数据，并将数据存储到MySQL的数据库中。</p><p>​    整个数据流转关系如下：</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/json%E4%B8%8Emysql%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="数据流转"></p><h5 id="2-Client-To-Server"><a href="#2-Client-To-Server" class="headerlink" title="2 Client To Server"></a>2 Client To Server</h5><p>​    UI 层使用的是JSON，支持数字、字符串、布尔型。JSON本身就是JavaScript Object，因此在JS端，<strong>所有的数据都是Number、Boolean、String 这三种类型。</strong></p><p>​    比较幸运，这几种数据类型在常规的编程语言中，都是包含的，如Golang。那么如何来接收从UI端下发的JSON Object，此时需要在Golang中创建一个对应的结构体。</p><ul><li><p><strong>创建1个Struct，建立成员变量名与json目标key的映射关系</strong></p><p>JS端下发如下一段JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"network_id"</span>:<span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"network_src_ip"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"network_dst_ip"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"network_dst_port"</span>:<span class="number">3306</span>,</span><br><span class="line">    <span class="attr">"network_desc"</span>:<span class="string">"MySQL"</span>,</span><br><span class="line">    <span class="attr">"network_status"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"network_time_available"</span>:<span class="string">"2018-07-20T14:42:26+08:00"</span>,</span><br><span class="line">    <span class="attr">"network_time_unavailable"</span>:<span class="string">"1970-01-01T08:00:01+08:00"</span>,</span><br><span class="line">    <span class="attr">"network_group"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"network_alarm_lasttime"</span>:<span class="string">"1970-01-01T08:00:01+08:00"</span>,</span><br><span class="line">    <span class="attr">"network_failed_cnt"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"network_disabled"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Golang中建立如下的结构体，<strong>为每个接口体成员打上Tag：JSON</strong></p><p><strong>Tag中的标签，则表示在JSON中的key</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PortMonitor <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">string</span>    <span class="string">`json:"network_id"`</span></span><br><span class="line">SrcIP     <span class="keyword">string</span>    <span class="string">`json:"network_src_ip"`</span></span><br><span class="line">DstIP     <span class="keyword">string</span>    <span class="string">`json:"network_dst_ip"`</span></span><br><span class="line">DstPort   <span class="keyword">int</span>       <span class="string">`json:"network_dst_port"`</span></span><br><span class="line">Desc      <span class="keyword">string</span>    <span class="string">`json:"network_desc"`</span></span><br><span class="line">Status    <span class="keyword">int</span>       <span class="string">`json:"network_status"`</span></span><br><span class="line">TimeOK    time.Time <span class="string">`json:"network_time_available"`</span></span><br><span class="line">TimeFail  time.Time <span class="string">`json:"network_time_unavailable"`</span></span><br><span class="line">Group     <span class="keyword">int</span>       <span class="string">`json:"network_group"`</span></span><br><span class="line">TimeAlarm time.Time <span class="string">`json:"network_alarm_lasttime"`</span></span><br><span class="line">FailCnt   <span class="keyword">int</span>       <span class="string">`json:"network_failed_cnt"`</span></span><br><span class="line">Disable   <span class="keyword">bool</span>      <span class="string">`json:"network_disabled"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>json.Unmarshal 完成转换</strong></p><p>数据到达服务端时的格式是：[]byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateProcMonitor</span><span class="params">(w http.ResponseWriter, r *http.Request, p httprouter.Params)</span></span> &#123;</span><br><span class="line">logger.I(<span class="string">"call CreateProcMonitor"</span>)</span><br><span class="line">res, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">uBody := &amp;process.ProcessMonitor&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(res, uBody); err != <span class="literal">nil</span> &#123;</span><br><span class="line">common.SendErrorResponse(w, common.ErrorRequestBodyParseFailed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := process.DBAddProcMonitorInfo(uBody); err != <span class="literal">nil</span> &#123;</span><br><span class="line">common.SendErrorResponse(w, common.ErrorDBError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">common.SendNormalResponse(w, <span class="string">"Create ProMonitor Info Success"</span>, http.StatusCreated)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用函数<code>json:Unmarshal</code>则可以完成JSON结构体向Struct结构体的转换，转换时按照Tag将JSON中的key与Struct中的成员变量名称相对应。</strong></p></li></ul><h5 id="3-Server-To-DB"><a href="#3-Server-To-DB" class="headerlink" title="3 Server To DB"></a>3 Server To DB</h5><p>  从Web服务端调用数据库API执行写库的操作，关键的函数为：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sqlClause := <span class="string">`INSERT INTO network (network_id, network_src_ip, network_dst_ip, network_dst_port, network_desc,</span></span><br><span class="line"><span class="string">             network_time_available, network_disabled) VALUES (?, ?, ?, ?, ?, ?, ?)`</span></span><br><span class="line"></span><br><span class="line">logger.I(<span class="string">"sqlClause Insert:%s"</span>, sqlClause)</span><br><span class="line">stmtIns, err = dbConn.Prepare(sqlClause)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = stmtIns.Exec(portInfo.ID, portInfo.SrcIP, portInfo.DstIP, portInfo.DstPort, portInfo.Desc, portInfo.TimeOK, portInfo.Disable)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  核心函数为：<code>stmtIns.Exec</code></p><p>  <strong>通过实验，证明Exec的参数传递时，支持传统的整型，布尔型，String、time.Time类型等。</strong></p><h5 id="4-DB-To-Server"><a href="#4-DB-To-Server" class="headerlink" title="4 DB To Server"></a>4 DB To Server</h5><p>  在数据库中存储的数据，通过接口读取到Go语言中，常用代码如下：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DBGetPortMonitorList</span><span class="params">(stmt <span class="keyword">string</span>)</span> <span class="params">([]*PortMonitor, error)</span></span> &#123;</span><br><span class="line">logger.T(<span class="string">"Enter Func: DBGetPortMonitorList"</span>)</span><br><span class="line">stmtOut, err := dbConn.Prepare(stmt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res []*PortMonitor</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := stmtOut.Query()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> stmtOut.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> network_id, network_src_ip, network_dst_ip, network_desc <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> network_dst_port, network_status, network_failed_cnt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> network_time_available, network_time_unavailable, network_alarm_lasttime time.Time</span><br><span class="line">        <span class="keyword">var</span> network_disabled <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := rows.Scan(&amp;network_id, &amp;network_src_ip, &amp;network_dst_ip, &amp;network_dst_port, &amp;network_desc, &amp;network_status,</span><br><span class="line">&amp;network_time_available, &amp;network_time_unavailable, &amp;network_alarm_lasttime, &amp;network_failed_cnt, &amp;network_disabled); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pm := &amp;PortMonitor&#123;</span><br><span class="line">ID:        network_id,</span><br><span class="line">SrcIP:     network_src_ip,</span><br><span class="line">DstIP:     network_dst_ip,</span><br><span class="line">DstPort:   network_dst_port,</span><br><span class="line">Desc:      network_desc,</span><br><span class="line">Status:    network_status,</span><br><span class="line">TimeOK:    network_time_available,</span><br><span class="line">TimeFail:  network_time_unavailable,</span><br><span class="line">TimeAlarm: network_alarm_lasttime,</span><br><span class="line">FailCnt:   network_failed_cnt,</span><br><span class="line">Disable:   network_disabled,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">append</span>(res, pm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  获取数据的关键接口是：<code>rows.Scan</code></p><p>  <strong>通过实验，证明Scan的参数传递时，支持传统的整型，布尔型，String、time.Time类型等。</strong></p><h5 id="4-Server-To-Client"><a href="#4-Server-To-Client" class="headerlink" title="4 Server To Client"></a>4 Server To Client</h5><p>  从Golang中将数据返回到客户端，如下代码所示：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProcMonitorList</span><span class="params">(w http.ResponseWriter, r *http.Request, p httprouter.Params)</span></span> &#123;</span><br><span class="line">logger.I(<span class="string">"call GetProcMonitorList"</span>)</span><br><span class="line"></span><br><span class="line">stmt := <span class="string">`SELECT id, process_ip, process_name, process_cnt, process_execmd, process_name_find,process_enable_lanch,</span></span><br><span class="line"><span class="string">        process_enable_alarm,process_alarm_time,process_groupid,process_switch FROM process`</span></span><br><span class="line">pm, err := process.DBGetProcMonitorList(stmt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.E(<span class="string">"Error When GetProcMonitorList"</span>)</span><br><span class="line">common.SendErrorResponse(w, common.ErrorDBError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp, err := json.Marshal(pm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">common.SendErrorResponse(w, common.ErrorInternalFaults)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">common.SendNormalResponse(w, <span class="keyword">string</span>(resp), <span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  核心的函数是：<code>json.Marshal</code></p><p>  这个函数将Struct结构体转变成JSON encode。</p><p>  <strong>通过实验，证明json.Marshal转换后，传递到前端支持传统的整型，布尔型，String、time.Time类型等。</strong></p><h5 id="5-time-Time的使用注意事项"><a href="#5-time-Time的使用注意事项" class="headerlink" title="5 time.Time的使用注意事项"></a>5 time.Time的使用注意事项</h5><p>  对于MySQL的驱动而言，使用Scan方法默认读取到的是<code>[]byte</code></p><p>  如果要使得MySQL驱动支持time.Time，需要设置DSN（Data Source Name）parseTime=true。    </p><p>  格式如下：</p><p>  <code>source=root:root@tcp(192.168.133.128:3306)/monitor?loc=Local&amp;parseTime=true&amp;charset=utf8</code></p><blockquote><p>The default internal output type of MySQL <code>DATE</code> and <code>DATETIME</code> values is <code>[]byte</code> which allows you to scan the value into a <code>[]byte</code>, <code>string</code> or <code>sql.RawBytes</code> variable in your program.</p><p>However, many want to scan MySQL <code>DATE</code> and <code>DATETIME</code> values into <code>time.Time</code> variables, which is the logical equivalent in Go to <code>DATE</code> and <code>DATETIME</code> in MySQL. You can do that by changing the internal output type from <code>[]byte</code> to <code>time.Time</code> with the DSN parameter <code>parseTime=true</code>. You can set the default <a href="https://golang.org/pkg/time/#Location" target="_blank" rel="noopener"><code>time.Time</code> location</a> with the <code>loc</code> DSN parameter.</p><p><strong>Caution:</strong> As of Go 1.1, this makes <code>time.Time</code> the only variable type you can scan <code>DATE</code> and <code>DATETIME</code> values into. This breaks for example <a href="https://github.com/go-sql-driver/mysql/wiki/Examples#rawbytes" target="_blank" rel="noopener"><code>sql.RawBytes</code> support</a>.</p><p>Alternatively you can use the <a href="https://godoc.org/github.com/go-sql-driver/mysql#NullTime" target="_blank" rel="noopener"><code>NullTime</code></a> type as the scan destination, which works with both <code>time.Time</code> and <code>string</code> / <code>[]byte</code>.</p></blockquote><h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h5><p>  从接口调用的角度：</p><p>  <img src="http://pogngdcwy.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="接口转换"></p><p>  在设计golang中的结构体时，按照常规的字段的类型声明就可以。<br>  另外，对于time.Time数据类型，要注意NULL默认值，如果数据库中存储的值为NULL，则会提示如下的错误：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql: Scan error on column index 6, name <span class="string">"network_time_available"</span>: unsupported Scan, storing driver.Value <span class="built_in">type</span> &lt;nil&gt; into <span class="built_in">type</span> *time.Time</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Golang-json-amp-amp-mysql-Data-Transfer&quot;&gt;&lt;a href=&quot;#Golang-json-amp-amp-mysql-Data-Transfer&quot; class=&quot;headerlink&quot; title=&quot;Golang: json &amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Qiniu Image Upload</title>
    <link href="http://yoursite.com/2019/03/16/hello-world/"/>
    <id>http://yoursite.com/2019/03/16/hello-world/</id>
    <published>2019-03-16T13:50:00.000Z</published>
    <updated>2019-04-17T01:55:07.415Z</updated>
    
    <content type="html"><![CDATA[<h4 id="this-article-is-for-uploading-image"><a href="#this-article-is-for-uploading-image" class="headerlink" title="this article is for uploading image"></a>this article is for uploading image</h4><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p><img src="http://pogngdcwy.bkt.clouddn.com/1552976689105wnudmnhb.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553059601588213uj3k1.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553087522877741tqn2j.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553088323397e3koel23.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553146529100fuzx5zg5.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553323825805h3m9fyh5.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553324079849p5my18w0.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553325130106bqbu1r52.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553325572416bdzomu9c.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553326014363qxzjszim.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553326410168bin01dni.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/15533268903407rf8t712.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553665481557hiswcash.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/15536661678177kftl47j.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/15536668410874cs8n7nh.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/15536682780863tlb5qss.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553669031313fxsrmnru.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553670923082otiy29qm.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553936043887yzxszlv3.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553936094979te3ks6dk.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553936312914bthcfqn8.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1553936390798ag0yt76b.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1554606604710wf3ixrnc.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/15546067047796uh8qmdg.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1554625808204f6rtvm2c.png?imageslim" alt="paste image"><br><img src="http://pogngdcwy.bkt.clouddn.com/1554625884152e7t4rr7i.png?imageslim" alt="paste image"></p><p><img src="http://pogngdcwy.bkt.clouddn.com/1554626227882wympqob5.png?imageslim" alt="paste image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;this-article-is-for-uploading-image&quot;&gt;&lt;a href=&quot;#this-article-is-for-uploading-image&quot; class=&quot;headerlink&quot; title=&quot;this article is for up
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建个人博客站点のSpecil Tips</title>
    <link href="http://yoursite.com/2019/03/16/test-my-site/"/>
    <id>http://yoursite.com/2019/03/16/test-my-site/</id>
    <published>2019-03-16T06:14:28.000Z</published>
    <updated>2019-03-19T21:58:43.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo搭建个人博客站点のSpecil-Tips"><a href="#Hexo搭建个人博客站点のSpecil-Tips" class="headerlink" title="Hexo搭建个人博客站点のSpecil Tips"></a>Hexo搭建个人博客站点のSpecil Tips</h3><h4 id="1-序言"><a href="#1-序言" class="headerlink" title="1 序言"></a>1 序言</h4><p>​    Hexo是非常流行的个人站点博客引擎，易学易学，社区教程也非常丰富。</p><p>​    搭建的教程基本上也是属于手把手级别的，很容易上手。</p><p>​    本文主要汇总在搭建过程中，自认为比较重要的事项进行记录，方便后续查看。</p><p>​    关键点：</p><ul><li>本文实际采用的网站使用GitHub托管</li><li>hexo-admin-qiniu需要结合七牛图床使用</li><li>域名解析与CNAME配置文件相结合</li></ul><h4 id="2-流程介绍"><a href="#2-流程介绍" class="headerlink" title="2 流程介绍"></a>2 流程介绍</h4><p>​    在搭建过程中，主要是参照如下链接：</p><p>​    其中重点参考了从“获得个人网站域名”到“绑定域名”这段过程，主题采用的是BlueLake。</p><p>​    从选用蓝湖主题开始，参考的是如下的步骤：</p><h4 id="3-Special-Tips"><a href="#3-Special-Tips" class="headerlink" title="3 Special Tips"></a>3 Special Tips</h4><h5 id="1-站点服务器选择"><a href="#1-站点服务器选择" class="headerlink" title="(1) 站点服务器选择"></a>(1) 站点服务器选择</h5><p>​    国内已经有比较多的云服务器可以选择，如阿里云，腾讯云，华为云等，但是需要注意：如果使用国内的服务器进行网站的搭建，需要对服务器进行许可认证，</p><p>​    即ICP备案。也可以使用国外的服务器，不需要对服务器进行备案。</p><p>​    本文采用的是vultr服务器，月租相对比较便宜，目前看运行还是比较稳定的。<img src="http://pogngdcwy.bkt.clouddn.com/1552749792980wg5ohkuv.png?imageslim" alt="vultr服务器"></p><h5 id="2-每次Deploy时都需要输入密码"><a href="#2-每次Deploy时都需要输入密码" class="headerlink" title="(2) 每次Deploy时都需要输入密码"></a>(2) 每次Deploy时都需要输入密码</h5><p>​    按照教程，在GitHub的SSH Key的设置界面，将服务器生成的公钥部署完毕。在真正部署时，还是需要输入密码，操作起来非常不便。</p><p>​    查阅资料后，将根config文件的repo属性进行了如下的更改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:XinhongWu/xinhongwu.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>​    配置完成后，则可以不需要输入密码，即可完成GitHub的推送。</p><h5 id="3-域名解析CNAME"><a href="#3-域名解析CNAME" class="headerlink" title="(3) 域名解析CNAME"></a>(3) 域名解析CNAME</h5><p>​    由于网站托管到GitHub上，因此可以使用 <code>github.io</code>格式的网址对网站进行访问。</p><p>​    对于新申请的域名，需要做一个域名解析的配置，详细配置如下：</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/1552750792933lyckuak7.png?imageslim" alt="域名解析"></p><p>​    需要配置一个CNAME类型和A类型的解析方式。</p><p>​    光解析到GitHub地址还不够，必须要让GitHub能鉴权通过新注册的域名，因此，需要在博客的source目录下配置一个CNAME文件：</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/1552750959901bpxv8n0a.png?imageslim" alt="cname文件"></p><p>​    最终会被解析到GitHub的如下位置：</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/15527510899073dtrltn9.png?imageslim" alt="paste image"> </p><h5 id="4-中文标题乱码"><a href="#4-中文标题乱码" class="headerlink" title="(4) 中文标题乱码"></a>(4) 中文标题乱码</h5><p>​    原因是根config的文件编码格式不是UTF-8，导致推送后显示乱码。</p><p>​    <code>解决办法</code>：使用Notepad将其编码修改为UTF-8即可。</p><h5 id="5-设置第三方评论"><a href="#5-设置第三方评论" class="headerlink" title="(5) 设置第三方评论"></a>(5) 设置第三方评论</h5><p>​    在原生的代码中，有不少的博客评论系统可以选择，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Cmments</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line"><span class="attr">  duoshuo:</span> <span class="comment">#chaooo ## duoshuo_shortname</span></span><br><span class="line"><span class="attr">  disqus:</span> <span class="comment">## disqus_shortname</span></span><br><span class="line"><span class="attr">  livere:</span> <span class="string">MTAyMC80MzIxNC8xOTc2MA==</span>  <span class="comment">## 来必力(data-uid)</span></span><br><span class="line"><span class="attr">  uyan:</span> <span class="comment">## 友言(uid)</span></span><br><span class="line"><span class="attr">  cloudTie:</span> <span class="comment">## 网易云跟帖(productKey)</span></span><br><span class="line"><span class="attr">  changyan:</span> <span class="comment">## 畅言需在下方配置两个参数，此处不填。</span></span><br><span class="line"><span class="attr">    appid:</span> <span class="comment">## 畅言(appid)</span></span><br><span class="line"><span class="attr">    appkey:</span> <span class="comment">##畅言(appkey)</span></span><br></pre></td></tr></table></figure><p>​    实际发现网易云跟帖已经停止服务了，畅言在申请时需要有网站的备案号，因此本文实际使用的是来必力。</p><p>​    （国外的服务器，不需要在国内备案，畅言可以尝试将没有申请过的备案号输入后申请）。</p><p>​    注意：来必力的ID可以在data-id中找到，如下所示：</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/1552751536094rrpchtmm.png?imageslim" alt="paste image"></p><h5 id="6-设置代码高亮"><a href="#6-设置代码高亮" class="headerlink" title="(6) 设置代码高亮"></a>(6) 设置代码高亮</h5><p>​    实际写MD发现，代码并未按照自己的需求高亮，查找资料后发现，还需要额外再添加一个设置：</p><p>​    参考：<a href="http://www.mdslq.cn/archives/7266c682.html" target="_blank" rel="noopener">http://www.mdslq.cn/archives/7266c682.html</a></p><p>​    在主题config文件中，添加如下的一行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure><h5 id="7-七牛云图片直传"><a href="#7-七牛云图片直传" class="headerlink" title="(7) 七牛云图片直传"></a>(7) 七牛云图片直传</h5><p>​    七牛云为新用户提供10GB的云存储空间，足够使用，如果每次都将图片上传到七牛图床，然后粘贴链接，步骤非常的繁琐，</p><p>​    因此尝试寻找自动粘贴后变成链接的工具。</p><p>​    在知乎的问答中：</p><p>​    找到一个插件 hexo-admin-qiniu，可以方便图片的插入。可以按照如下的步骤来进行：</p><p>​        步骤1：在七牛中建立一个存储空间（Bucket），地区一定要选择<code>华东</code>！一定要选择<code>华东！一定要选择</code>华东！，如下所示：</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/15527521861694j49ilyu.png?imageslim" alt="paste image"></p><p>​    图中的标记部分，在后序会用到：BucketHost</p><p>​    步骤2:安装 hexo-admin-qiniu插件</p><p>​    按照如下的教程，安装好插件：<a href="http://lazyboy.site/hexo-admin-qiniu/" target="_blank" rel="noopener">http://lazyboy.site/hexo-admin-qiniu/</a></p><p>​    在根config文件中，配置好七牛的图床，一个参考的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line"><span class="attr">  qiniuCfg:</span></span><br><span class="line"><span class="attr">      imageslim:</span> <span class="literal">true</span>  <span class="comment"># 启动图片瘦身，仅华东区bucket可以使用</span></span><br><span class="line"><span class="attr">      AccessKey:</span> <span class="string">'qS-9v53dFGLjk8KVoyFpx587inU36quVSE4jl2-V'</span></span><br><span class="line"><span class="attr">      SecretKey:</span> <span class="string">'cM_HQcu17tXg8jVoP07i0UiuxifmiDmJSdUxZHvc'</span></span><br><span class="line"><span class="attr">      BucketName:</span> <span class="string">'blogmd'</span></span><br><span class="line"><span class="attr">      bucketHost:</span> <span class="string">'pogngdcwy.bkt.clouddn.com'</span></span><br></pre></td></tr></table></figure><p>​    </p><p>​    步骤3:启动服务，在Windows中可以直接访问hexo-admin。</p><p>​    在hexo-admin中，随意打开一篇文章，将图片粘贴，则会自动生成一个链接，在MarkDown编辑器中，直接粘贴此链接即可。</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/1552752711545bpv5novc.png?imageslim" alt="paste image"></p><p>​    同时，在七牛的后台可以看到刚才操作中产生的图片：</p><p>​    <img src="http://pogngdcwy.bkt.clouddn.com/1552752785691zhloxezi.png?imageslim" alt="paste image"></p><h5 id="8-设置hexo-admin开机启动"><a href="#8-设置hexo-admin开机启动" class="headerlink" title="(8) 设置hexo-admin开机启动"></a>(8) 设置hexo-admin开机启动</h5><p>​    Ubuntu 18.10与早期的系统有差异，开机启动项目的管理，使用的是Systemd，不再是initd系统。</p><p>​        配置起来也比较简单，因为存在如下的功能：</p><blockquote><p>​    The <code>rc-local.service</code> already exists in systemd and the service file suggests that the <code>rc.local</code>, if it exists and is executable, <strong>gets pulled automatically into multi-user.target</strong></p></blockquote><p>​    也就是说rc.local将会被系统默认启动。参考链接：</p><p>​    <a href="https://askubuntu.com/questions/886620/how-can-i-execute-command-on-startup-rc-local-alternative-on-ubuntu-16-10" target="_blank" rel="noopener">https://askubuntu.com/questions/886620/how-can-i-execute-command-on-startup-rc-local-alternative-on-ubuntu-16-10</a></p><p>​    示例，在rc.local中添加如下的执行语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /home/cms/blog;hexo server &amp;</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>​    然后reboot，则会发现hexo程序在后台执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vultr:~<span class="comment"># ps -ef | grep hexo</span></span><br><span class="line">root       645     1  9 21:44 ?        00:00:02 hexo</span><br><span class="line">root       953   936  0 21:44 pts/0    00:00:00 grep --color=auto hexo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hexo搭建个人博客站点のSpecil-Tips&quot;&gt;&lt;a href=&quot;#Hexo搭建个人博客站点のSpecil-Tips&quot; class=&quot;headerlink&quot; title=&quot;Hexo搭建个人博客站点のSpecil Tips&quot;&gt;&lt;/a&gt;Hexo搭建个人博客站点のS
      
    
    </summary>
    
    
  </entry>
  
</feed>
